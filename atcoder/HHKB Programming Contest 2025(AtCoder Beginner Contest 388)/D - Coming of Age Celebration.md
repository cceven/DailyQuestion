# [[ABC388D] Coming of Age Celebration](https://atcoder.jp/contests/abc388/tasks/abc388_d)

## 题面翻译

### 问题陈述

在某个星球上，有 $N$ 个外星人，他们都是未成年人。

第 $i$ 个外星人目前拥有 $A_i$ 个石头，并将在 $i$ 年后成为成年人。

当一个人成为这个星球上的成年人时，

每一个拥有至少一块石头的**成年人**都会把一块石头作为祝贺礼物送给刚刚成年的外星人。找出每个外星人在 $N$ 年后会有多少石头。

假设未来不会有新的外星人诞生。

### 约束

- $1 \leq N \leq 5 \times 10^5$

- $0 \leq A_i \leq 5 \times 10^5$

-所有输入值均为整数。

### 输入

输入来自标准输入，格式如下：

 $N$

 $A_1$ $A_2$ $\ldots$ $A_N$

### 输出

假设 $B_i$ 是第 $i$ 个外星人在 $N$ 年后拥有的石头数量。按顺序打印 $B_1, B_2, \ldots, B_N$ ，用空格分隔。

### 样本输入1
```
4
5 0 9 3
```

### 示例输出1

```
2 0 10 5
```

设 $C_i$ 为第 $i$ 个外星人在给定时间拥有的石头数量。

最初， $(C_1, C_2, C_3, C_4) = (5, 0, 9, 3)$ 。

$1$ 年后， $(C_1, C_2, C_3, C_4) = (5, 0, 9, 3)$ 。

经过 $2$ 年， $(C_1, C_2, C_3, C_4) = (4, 1, 9, 3)$ 。

$3$ 年后， $(C_1, C_2, C_3, C_4) = (3, 0, 11, 3)$ 。

$4$ 年后， $(C_1, C_2, C_3, C_4) = (2, 0, 10, 5)$ 。

### 样本输入2

```
5
4 6 7 2 5
```

### 示例输出2

```
0 4 7 4 9
```

### 样本输入3

```
10
2 9 1 2 0 4 6 7 1 5
```

### 示例输出3

```
0 2 0 0 0 4 7 10 4 10
```

## 题目描述

[problemUrl]: https://atcoder.jp/contests/abc388/tasks/abc388_d

ある星には $ N $ 人の宇宙人がおり、全員未成年です。

$ i $ 人目の宇宙人は現在 $ A_i $ 個の石を所持しており、ちょうど $ i $ 年後に成人します。

この星では誰かが成人するとき、石を $ 1 $ 個以上所持している**成人**全員が、成人する宇宙人に成人祝いとして石を $ 1 $ 個渡します。

$ N $ 年後に各宇宙人が所持している石の個数を求めてください。

ただし、今後新たな宇宙人は産まれないものとします。

## 输入格式

入力は以下の形式で標準入力から与えられる。

> $ N $ $ A_1 $ $ A_2 $ $ \ldots $ $ A_N $

## 输出格式

$ N $ 年後に $ i $ 人目の宇宙人が所持している石の個数を $ B_i $ として $ B_1,\ B_2,\ \ldots,\ B_N $ をこの順に空白区切りで出力せよ。

## 样例 #1

### 样例输入 #1

```
4
5 0 9 3
```

### 样例输出 #1

```
2 0 10 5
```

## 样例 #2

### 样例输入 #2

```
5
4 6 7 2 5
```

### 样例输出 #2

```
0 4 7 4 9
```

## 样例 #3

### 样例输入 #3

```
10
2 9 1 2 0 4 6 7 1 5
```

### 样例输出 #3

```
0 2 0 0 0 4 7 10 4 10
```

## 提示

### 制約

- $ 1\ \leq\ N\ \leq\ 5\ \times\ 10^5 $
- $ 0\ \leq\ A_i\ \leq\ 5\ \times\ 10^5 $
- 入力される値はすべて整数

### Sample Explanation 1

$ i $ 人目の宇宙人が持っている石の個数を $ C_i $ で表します。 はじめ $ (C_1,\ C_2,\ C_3,\ C_4)\ =\ (5,\ 0,\ 9,\ 3) $ です。 $ 1 $ 年後には $ (C_1,\ C_2,\ C_3,\ C_4)\ =\ (5,\ 0,\ 9,\ 3) $ となります。 $ 2 $ 年後には $ (C_1,\ C_2,\ C_3,\ C_4)\ =\ (4,\ 1,\ 9,\ 3) $ となります。 $ 3 $ 年後には $ (C_1,\ C_2,\ C_3,\ C_4)\ =\ (3,\ 0,\ 11,\ 3) $ となります。 $ 4 $ 年後には $ (C_1,\ C_2,\ C_3,\ C_4)\ =\ (2,\ 0,\ 10,\ 5) $ となります。

## 代码

### 原代码（测试点通过，提交不通过TLE）

![image-20250117015201070](https://gitee.com/chen-houchao/images/raw/master/img/20250117015201168.png)

```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl "\n"

void solve() {
  int N;
  cin >> N;
  vector<int> A(N + 1);
  for (int i = 1; i <= N; i++) {
    cin >> A[i];
  }
  for (int i = 1; i <= N; i++) {
    A[i] += i - 1;  // 先获得宝石
    int temp = A[i];
    A[i]     = max(A[i] - (N - i), 0);  // 赠送宝石
    // 如果赠送后宝石数为0了
    if (A[i] == 0) {
      for (int j = i + temp + 1; j <= N; j++) {
        A[j]--;
      }
    }
  }
  for (int i = 1; i <= N; i++) {
    cout << A[i] << " ";
  }
}

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  solve();
  return 0;
}
```

### 优化后的代码

![image-20250117015217830](https://gitee.com/chen-houchao/images/raw/master/img/20250117015217922.png)

```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl "\n"

void solve() {
  int N;
  cin >> N;
  vector<int> A(N + 1);
  for (int i = 1; i <= N; i++) {
    cin >> A[i];
  }
  for (int i = 1; i <= N; i++) {
    A[i] += i - 1;  // 先获得宝石
  }
  vector<long long> diff(N + 1, 0);
  long long dec = 0;  // 跟踪当前的减少量
  for (int i = 1; i <= N; i++) {
    dec += diff[i];  // 首先更新减少量
    A[i] += dec;     // 更新宝石数量，也就是减少对应的量
    long long temp = A[i];
    A[i]           = max(A[i] - (N - i), 0);  // 赠送宝石
    if (A[i] == 0 && i + temp + 1 <= N) {     // 如果赠送后宝石数为0
      diff[i + temp + 1]--;                   // 更新减少量
    }
  }

  // 输出结果
  for (int i = 1; i <= N; i++) {
    cout << A[i] << " ";
  }
}

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  solve();
  return 0;
}
```

- 使用了`diff`和`dec`来存储减少量。`dec`就是现在移动到的位置应该减少的量，`diff`代表当前位置及之后的位置都需要再多减1