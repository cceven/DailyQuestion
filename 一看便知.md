## 2.16 

- `INT_MIN`、`INT_MAX`
- `string`中的`erase()`与`unique()`一起使用可以删除所有的重复元素（需要先排序，因为`unique()`只能消除挨在一起的重复的元素）
- `string`当中找不到指向的是`string::npos`而不是`end()`
- 逆向迭代是`rbegin()`和`rend()`

## 2.19

- 字符串转换为输入流，然后就可以按照特定的字符将字符串切割成几部分


![](https://gitee.com/chen-houchao/images/raw/master/img/20250219205202354.png)

![image-20250219220548984](https://gitee.com/chen-houchao/images/raw/master/img/20250219220549015.png)

- `unordered_map`类型数据的初始化方法

  ![image-20250219211212095](https://gitee.com/chen-houchao/images/raw/master/img/20250219211212138.png)

- 输出的控制方式：`setw()`控制字段宽度，`setfill()`设置填充字符（默认为空格），`left（right）`控制对齐方向（默认右对齐）

- 运用`rfind()`从背后开始查找

- 最快的判断是否为质数的函数

  ![image-20250220002011231](https://gitee.com/chen-houchao/images/raw/master/img/20250220002011290.png)

## 2.20

- `while()`的条件里面可以进行输入和判断

  ![image-20250220150632515](https://gitee.com/chen-houchao/images/raw/master/img/20250220150632557.png)

- 使用二分查找`lowe_bound()`和`upper_bound()`返回的类型是迭代器，所以不能用`int`来存储。下面代码中的`left`和`right`的值是符合要求的第一个数字的值，而不是索引，如果要转换为索引就需要进一步操作（减去`begin()`）

  ![](https://gitee.com/chen-houchao/images/raw/master/img/20250220183402663.png)

- `to_string()`函数可以将某个其他类型的变量转换为`string`类型

- `toupper()`可以把小写字母转换为大写字母，此外还有`tolower()`将大写字母转换为小写

## 2.21

- 使用`埃拉托斯特尼筛法`找到一个区间中的所有素数

  ![image-20250221101050013](https://gitee.com/chen-houchao/images/raw/master/img/20250221101050078.png)

- `isalnum()`用来判断是否为字母或数字、`isdigit()`用来判断是否为数字、`isalpha()`用来判断是否为字母

- `isupper()`（判断是否为大写字母）、`islower()`（判断是否为小写字母）、`toupper()`（转换为大写字母）、`tolower()`（转换为小写字母）

## 2.22

- `accumulate()`函数求和（还可以使用`reduce()`）

## 2.23

- `iota()`函数赋值，依次增加：`iota(parent.begin(), parent.end(), 0)`

- `remove()`函数和`erase()`函数搭配使用删除某种特定的元素

```cpp
    // 删除所有星号
    s.erase(remove(s.begin(), s.end(), '*'), s.end());
```

- `unique()`只能找到相邻的重复元素，所以使用`unique()`之前一定要先排序！！

  ![image-20250223172918108](https://gitee.com/chen-houchao/images/raw/master/img/20250223172918325.png)

- `round()`用来四舍五入
- 使用`setw()`和`setfill()`不能不输出任何东西，至少输出一个空字符串`""`

## 2.24

- `string`类型的四个函数`find_first_of()`、`find_first_not_of()`、`find_last_of()`、`find_last_not_of()`
- `substr()`只加一个参数就会得到该位置及之后的字符串

## 2.25

- **逆向思维**

- ![](https://gitee.com/chen-houchao/images/raw/master/img/20250302001815978.png)
  
- 矩阵的乘法

  ![image-20250225190158815](https://gitee.com/chen-houchao/images/raw/master/img/20250225190158868.png)

- 链式条件表达式，通过`tie()`构建元组实现多条件排序表达式

  ![img](https://gitee.com/chen-houchao/images/raw/master/img/20250305005104507.png)

- `lower_bound()`默认用于升序情况，如果要用于降序情况那么需要给出第四个参数`greater<int>`

## 2.26

- `string()`的默认构造函数的用法

  ![image-20250226182449532](https://gitee.com/chen-houchao/images/raw/master/img/20250226182449614.png)

- 公式的转换

  ![383051d4cd41f94f9c38dd648bb55927_720](https://gitee.com/chen-houchao/images/raw/master/img/20250226182945716.png)

  ![image-20250226182636046](https://gitee.com/chen-houchao/images/raw/master/img/20250226182956200.png)

  

- 数字太长不能进行除法，自己手动模拟除法的过程

  ![image-20250226182604185](https://gitee.com/chen-houchao/images/raw/master/img/20250226183018882.png)

- 不要轻易在`for()`循环里面使用`size()`等函数，因为可能随着你的`for()`循环的进行，这些函数的值在变化

- `unordered_map`的查找不能使用`find(.begin(),.end(),x)`，要使用`mp.find(x)`

## 2.27

- `sort()`函数和`lower_bound()`函数对`pair<>`类型的比较规则的自定义

  ![image-20250227100152944](https://gitee.com/chen-houchao/images/raw/master/img/20250227100235675.png)

- 不能在有`cin`的循环里面提前判断然后结束判断，不然会导致后面的输入全错

- 下面的代码中，当`ans2`为空时就会出现问题（下面的代码是已修复的版本），因为`ans2.size()`的特殊类型（`size_t`)不支持负数，当为0时再减去1就会出现问题。

  ![image-20250227180203857](https://gitee.com/chen-houchao/images/raw/master/img/20250227180203908.png)

- 构建最小堆。逐个插入数字到最小堆末尾，循环操作：将新插入的数字与它的父节点（如果最小堆下标从1开始，那么一个数字的父节点就是该数的下标除以2）进行比较，如果小于它的父节点，那么替换新数和它的父节点。重复循环直到新数变为最小堆的根或者新数大于它的父节点。（最大堆同理）

- 广度优先搜索，类似于树的层序遍历。

  ![image-20250227220711369](https://gitee.com/chen-houchao/images/raw/master/img/20250227220711471.png)

- 如果`num%a=num%b`，那么`num=k*lcm(a,b)+r`，其中`r<min(a,b)`

## 3.1

- `*max_element()`可以找到`vector`容器中的最大值
- 如果要实现除法向上取整可以借鉴`sum += (nums[i] + mid - 1)/mid`

- 如果要访问`unordered_set`的第一个元素可以使用`*name.begin()`

  ![](https://gitee.com/chen-houchao/images/raw/master/img/20250302002018497.png)

## 3.2

- `sort()`排序是不稳定的排序，如果需要稳定的排序可以使用`stable_sort()`

- 注意题目的条件，有些条件虽然只在某一处输出的需求说了，但是可能所有输出都需要用到这个条件

- 重载结构体的比较（可以用于`find()`）

  ![image-20250302121412791](https://gitee.com/chen-houchao/images/raw/master/img/20250302121648647.png)

- 如果需要不重复的条件的话可以使用`unordered_set`来判断是否已经存在，方便且节省时间复杂度

- 判断是否为完全二叉树和层序遍历差不多，只不过判断是否为完全二叉树的时候不管子节点是否为空都要入队

  ![image-20250302150259819](https://gitee.com/chen-houchao/images/raw/master/img/20250302150259958.png)

- 通过完全二叉树的后序遍历找到它的层序遍历

  ![image-20250302160942421](https://gitee.com/chen-houchao/images/raw/master/img/20250302160942565.png)

  

## 3.3

- `ranges::max()`对二维数组的使用

  ![image-20250303094251582](https://gitee.com/chen-houchao/images/raw/master/img/20250303094251724.png)

- 使用`map`构建差分数组，避免超出内存限制

- `Floyd`算法，求最短带权路径

  ![image-20250304004018721](https://gitee.com/chen-houchao/images/raw/master/img/20250304004018787.png)

## 3.4

- `DFS`的两种实现方式，非递归（使用栈），递归（不使用栈），不能够混用了

- 当有特殊的键（`vector`或`pair`）的时候用不了`unordered_map`可以直接使用`map`。如果需要排序的话可以把`map`的内容复制到`vector`进行排序

- `unordered_set`可以直接通过`*max_element`找到最大值

  ![](https://gitee.com/chen-houchao/images/raw/master/img/20250304221733178.png)

- `tuple`（可以类比`pair`）类型的用法。`tuple<T,T,T>`指定`tuple`类型。`make_tuple(x, y, z)`创造`tuple`类型的元素。`get<0>(my_tuple)`得到`tuple`的第0（1、2）位元素

## 3.5

- `lambda`函数最后面可以加一个`()`表示立即调用

  ![image-20250305194247264](https://gitee.com/chen-houchao/images/raw/master/202503051942300.png)

## 3.7

- `map<>`类型删除元素用的是迭代器

  ![image-20250307195543227](https://gitee.com/chen-houchao/images/raw/master/202503071955272.png)

## 3.8

- **树的前序遍历（非递归）**：同样还是使用栈来进行维护。入栈的时候先入栈右边的节点（因为要更后输出，所以要先入栈），然后入栈左边的节点（因为要更早一点进行输出）。在每一次循环`top()`的时候进行输出

  ![image-20250308104304587](https://gitee.com/chen-houchao/images/raw/master/202503081043642.png)

- 如果要对整个字符串进行大写字母转换为小写字母的操作，不能使用`tolower()`函数，因为`tolower()`函数是对字符进行操作而不是字符串。如果要对字符串进行操作可以使用`transform()`函数，具体操作如下

  ![image-20250308182403523](https://gitee.com/chen-houchao/images/raw/master/202503081824561.png)

- `string`没有`count()`函数，如果要查找个数那么需要使用`find()`函数进行循环查找

  ![image-20250308182438505](https://gitee.com/chen-houchao/images/raw/master/202503081824546.png)

- `string`的`replace()`函数

## 3.10

- `multiset`的使用，类似于`set`，可以用于存储元素是否存在。但是`multiset`允许重复的元素

## 3.11

- 如果要从大到小进行排序的话可以直接使用`greater<int>()`

- 进行条件判断时注意先后顺序，要先判断是否越界再判断是否有效，否则可能会发生越界错误

  ![image-20250311144806484](https://gitee.com/chen-houchao/images/raw/master/202503111448511.png)

## 3.12

- 输入十六进制使用`cin >> hex >> num;`

  ![image-20250312115919952](https://gitee.com/chen-houchao/images/raw/master/202503121159006.png)

- `x + y = 2 * (x & y ) + x ^ y`

  ![5cdbc1c1564804249e8934f8f1201ee7_720](https://gitee.com/chen-houchao/images/raw/master/202503121509201.png)

## 3.16

### 找到1~x中所有的因数

![image-20250316173955181](https://gitee.com/chen-houchao/images/raw/master/202503161739350.png)

![image-20250316174055801](https://gitee.com/chen-houchao/images/raw/master/202503161740858.png)

### 进行向上取整

使用`(p + mid - 1) / mid`

![a44da9c2d70814f72e99a9fc4da363b4_720](https://gitee.com/chen-houchao/images/raw/master/202503161851384.png)

## 3.17

### 判断两个数字的奇偶性

判断两个数字的奇偶性可以使用`a & 1 == b & 1`，也可以使用`a % 2 == b % 2`

### 判断一个二进制数最多含有一个1

可以通过判断`(m & (m - 1)) == 0`来判断这个二进制数是否最多只含有一个1

奇数长度的回文字符串，奇数数量的字符只有一个。偶数长度的回文字符串，不存在奇数数量的字符。

## 3.18

### 矩阵横坐标与纵坐标的关系

从一个点出发向四个顶点的方向进行延伸，我们可以得到这样的性质。从左上到右下的一条线上的每个点的`x - y`的值是相等的。从左下到右上的一条线上的每个点的`x + y`的值是相等的。

![image-20250318131250556](https://gitee.com/chen-houchao/images/raw/master/202503181312588.png)

### 求最大公约数

![image-20250319003803064](https://gitee.com/chen-houchao/images/raw/master/202503190038109.png)

### 不要随便使用`pow()`函数

不要随便使用`pow()`函数，可能会产生误差导致结果错误。如果需要使用，可以自己写一个，或者直接硬乘。