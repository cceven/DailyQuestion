# 专业基本能力测试——西爱吃西

# 判断题

## 1-1

![image-20241106171327099](https://gitee.com/chen-houchao/images/raw/master/image-20241106171327099.png)

T

C语言的数组下标从0开始。

## 1-2

![image-20241106171333469](https://gitee.com/chen-houchao/images/raw/master/image-20241106171333469.png)

T

这是因为浮点数在计算机中的存储方式是有限的，可能会存在精度误差。因此，直接判断两个浮点数是否相等可能会出现错误的结果。应该使用一些特定的方法来比较浮点数，例如比较它们的差值是否小于一个很小的数，或者使用一些库函数来进行比较，这样可以避免因精度误差而导致的错误判断。

## 1-3

![image-20241106171338333](https://gitee.com/chen-houchao/images/raw/master/image-20241106171338333.png)

F

C语言程序区分大小写。

![image-20241106171343447](https://gitee.com/chen-houchao/images/raw/master/image-20241106171343447.png)

T

函数重载是指同一个函数名可以有多个版本，这些版本必须在参数个数或者参数类型上有所不同，与返回值无关。

## 1-5

![image-20241106171351775](https://gitee.com/chen-houchao/images/raw/master/image-20241106171351775.png)

T

重载不能改变运算符的优先级和结合性。

## 1-6

![image-20241106171359110](https://gitee.com/chen-houchao/images/raw/master/image-20241106171359110.png)

F

- 正确部分

  派生类对象可以直接转换为基类对象：这部分是正确的。派生类对象可以直接赋值给基类对象，这种转换被称为“向上转换”或“上行转换”，是安全的，并且是自动进行的。

- 错误部分

  基类对象可以直接转换为派生类对象：这部分是不正确的。基类对象不能直接转换为派生类对象。这种转换被称为“向下转换”或“下行转换”，需要进行类型检查，通常使用C++的dynamic_cast运算符。如果基类对象没有包含派生类对象的实际实例，这种转换是危险的，并且会失败。

## 1-7

![image-20241106171404759](https://gitee.com/chen-houchao/images/raw/master/image-20241106171404759.png)

T

与单继承中派生类的构造函数类似，多重继承派生类的构造函数不但要对派生类中新增成员完成初始化，还要依次对各基类的继承成员进行初始化。

## 1-8

![image-20241106171410065](https://gitee.com/chen-houchao/images/raw/master/image-20241106171410065.png)

T

局部变量可以和成员变量重名，不加`this`修饰时，优先使用最近的变量。

## 1-9

![image-20241106171415357](https://gitee.com/chen-houchao/images/raw/master/image-20241106171415357.png)

T

正确的。比如：

```c++
Student()
{
    string name;
    Student()
    {
        
    }
    Student(string name)
    {
        this->name = name;
    }
}
int main()
{
    Student stuA = new Student("小明");
    Student stuB = new Student("小王");
}
```

`stuA`和`stuB`的`name`是不同的值

## 1-10（？）

![image-20241106171421587](https://gitee.com/chen-houchao/images/raw/master/image-20241106171421587.png)

T

## 1-11

![image-20241106171426122](https://gitee.com/chen-houchao/images/raw/master/image-20241106171426122.png)

T

所有NP完全问题（NP-Complete问题）都是NP问题。这是因为NP完全问题是NP问题中的一个子集，并且具有额外的性质：每个NP完全问题都可以被归约（Reduction）到另一个NP完全问题。因此，所有NP完全问题必然也是NP问题。

## 1-12

![image-20241106171435141](https://gitee.com/chen-houchao/images/raw/master/image-20241106171435141.png)

F

对于频繁进行不同下标元素的插入和删除操作，**链式存储结构**通常会比顺序存储结构更好。原因是：

- **顺序存储结构**（如数组）在插入或删除元素时，可能需要移动大量元素，以保证元素的连续性。这种操作的时间复杂度通常为 O(n)，尤其是当插入或删除的位置接近数组的开始或中间时。
- **链式存储结构**（如链表）则不需要移动其他元素，只需要调整相邻节点的指针，因此插入和删除操作通常可以在 O(1) 时间内完成，前提是你已经定位到正确的位置。

## 1-13

![image-20241106171440273](https://gitee.com/chen-houchao/images/raw/master/image-20241106171440273.png)

T

栈是先进后出的线性表。

## 1-14

![image-20241106171446642](https://gitee.com/chen-houchao/images/raw/master/image-20241106171446642.png)

F

队列是先进先出的线性表。

# 单选题

## 2-1

![image-20241106171454706](https://gitee.com/chen-houchao/images/raw/master/image-20241106171454706.png)

A

**标识符的组成：**

1. **字母**（A-Z, a-z）：
   - 标识符可以包含字母，通常不区分大小写（但有些语言如Java区分大小写）。
2. **数字**（0-9）：
   - 标识符可以包含数字，但**不能以数字开头**。
3. **下划线**（_)：
   - 下划线是有效的标识符字符，通常用于提高代码的可读性，比如 `my_variable`。

**不能作为标识符的内容：**

1. **保留字/关键字**：
   - 标识符不能是语言的保留字或关键字。例如，C、C++中的 `int`、`while`，Java中的 `public`、`class`，Python中的 `def`、`for` 都不能用作标识符。
2. **空格、标点符号和特殊字符**：
   - 标识符中不能包含空格、运算符、标点符号（如 `+`, `-`, `*`, `&`），以及其他特殊字符（如 `@`, `#`, `$` 等）。
3. **其他语言限制**：
   - 某些语言可能有额外的规则，例如C++标准中有对标识符命名的长度和使用某些字符的限制。

## 2-2

![image-20241106171501297](https://gitee.com/chen-houchao/images/raw/master/image-20241106171501297.png)

A

**解析：**

1. **函数的定义不能嵌套**：
   - 在大多数编程语言中，函数的定义**不能嵌套**在其他函数内部。也就是说，你不能在一个函数内部再定义另一个函数。比如，在C、C++、Java和Python等语言中，函数定义通常是独立的，并且只能在文件的作用域中（或类的作用域中）定义，而不能在另一个函数的定义内部定义。
   
2. **函数的调用可以嵌套**：
   - **函数的调用可以嵌套**，即在一个函数的实现中可以调用其他函数，甚至可以调用自身（递归）。嵌套调用是常见的编程模式。例如，函数A可以调用函数B，而函数B也可以调用函数C，函数A和B的调用关系就是嵌套的。

**示例：**

1. **函数定义不能嵌套**（不允许在一个函数内部定义另一个函数）：
   
   ```cpp
   // 错误示范
   void outerFunction() {
       void innerFunction() {   // 不能在函数内部定义另一个函数
           // ...
       }
   }
   ```
   
2. **函数调用可以嵌套**（可以在一个函数中调用其他函数）：
   ```cpp
   // 正确示范
   void foo() {
       bar();   // foo调用bar
   }
   
   void bar() {
       // ...
   }
   ```

总结：函数的定义通常不能嵌套，而函数的调用（包括嵌套调用）是允许的。

## 2-3

![image-20241106171508211](https://gitee.com/chen-houchao/images/raw/master/image-20241106171508211.png)

D

选项A：`break`语句不仅可以用于`switch`语句，还可以用于循环语句（如`for`、`while`等），以跳出循环。

选项B：`default`是可选的，即使在`switch`语句中没有`default`子句，语法依然是合法的。

选项C：虽然在大多数情况下，`break`语句与`switch`语句中的`case`配对使用以防止“贯穿”（fall-through），但它不是必须的。可以省略`break`语句以使程序继续执行后续的`case`块。

选项D：如上所述，`break`语句在`switch`语句中是可选的，而不是必须的。省略它会导致程序“贯穿”到下一个`case`块。

## 2-4

![image-20241106171513830](https://gitee.com/chen-houchao/images/raw/master/image-20241106171513830.png)

A

由于是`do-while`，不管条件如何会先执行一遍循环，执行`x=x*x`后`x`的值变为1，此时不符合判断条件`x==0`，跳出循环，所以只执行一次。

## 2-5

![image-20241106171519400](https://gitee.com/chen-houchao/images/raw/master/image-20241106171519400.png)

D

结构程序设计的三种结构是：**顺序结构**、**选择结构**、**循环结构**。

## 2-6

![image-20241106171526426](https://gitee.com/chen-houchao/images/raw/master/image-20241106171526426.png)

D

**解析：**

- **A. 指针可以进行加、减等算术运算**：
  这是正确的。在C/C++等语言中，指针支持加法和减法运算。例如，你可以增加指针的值来让它指向下一个内存单元，或减去一个值来让它指向前一个内存单元。指针算术运算通常是基于数据类型大小的。

- **B. 指针中存放的是地址值**：
  这是正确的。指针变量存储的是一个内存地址，该地址指向一个具体的数据对象或函数。

- **C. 指针是一个变量**：
  这是正确的。指针是一个变量，和其他变量一样，它也有自己的存储空间，并且存储的是一个地址。

- **D. 指针变量不占用存储空间**：
  这是错误的。指针变量本身是一个变量，它占用一定的存储空间。在大多数现代系统中，指针通常占用 4 或 8 个字节（具体大小取决于系统架构，例如32位系统上通常是4字节，64位系统上通常是8字节）。

因此，**D** 选项是错误的，指针变量和其他类型的变量一样，**也需要占用存储空间**。

## 2-7

![image-20241106171532565](https://gitee.com/chen-houchao/images/raw/master/image-20241106171532565.png)

B

A. 递归函数是自己调用自己。这个说法是正确的。

B. 递归函数的运行速度很快。这个说法是错误的。递归函数由于需要进行多次调用，运行速度通常较慢，尤其是在递归深度较大时。

C. 递归函数占用较多的存储空间。这个说法是正确的。因为每次递归调用都会占用堆栈空间，因此递归函数通常比迭代方法占用更多的存储空间。

D. 递归函数的运行速度一般比较慢。这个说法是正确的。

所以，正确答案是 B。

## 2-8

![image-20241106171540629](https://gitee.com/chen-houchao/images/raw/master/image-20241106171540629.png)

A。

当`i`为99时，`i`%100+1为100，结束循环。

## 2-9

![image-20241106171548290](https://gitee.com/chen-houchao/images/raw/master/image-20241106171548290.png)

D

面向对象程序设计通过封装、继承和多态等特性，使得代码可以被复用，提高了开发效率和软件质量。这种编程范式有助于创建模块化、可扩展和易于维护的软件系统。

## 2-10

![image-20241106171553488](https://gitee.com/chen-houchao/images/raw/master/image-20241106171553488.png)

A

## 2-12

![image-20241107083004508](https://gitee.com/chen-houchao/images/raw/master/image-20241107083004508.png)

A。`main` 函数是程序的入口点，每个C/C++程序都必须包含一个 `main` 函数，不然程序无法编译和执行。

## 2-13

![image-20241106171606646](https://gitee.com/chen-houchao/images/raw/master/image-20241106171606646.png)

C

## 2-14

![image-20241106171633328](https://gitee.com/chen-houchao/images/raw/master/image-20241106171633328.png)

D

具有以下形态：

1. 一个根节点，左子树有两个节点。
2. 一个根节点，右子树有两个节点。
3. 一个根节点，左子树有一个节点，右子树有一个节点。
4. 一个根节点，左子树有一个节点，左子树的右子树有一个节点。
5. 一个根节点，右子树有一个节点，右子树的左子树有一个节点。

扩展：n个节点可以构造的二叉树形态数量：
$$
f(n) = \frac{(2n)!}{(n+1)!n!}
$$

## 2-15

![image-20241106171638525](https://gitee.com/chen-houchao/images/raw/master/image-20241106171638525.png)

C

**二叉树高度的范围**

计算具有 n 个节点的二叉树的高度可以从以下两个极端情况考虑：完全二叉树和链式二叉树（最坏情况）。

1. **完全二叉树**（最小）：
   - 在这种情况下，二叉树的高度是最小的。
   - 完全二叉树的高度为 $\log_2(n+1)$（向上取整）或者$\log_2(n)$（向下取整再加1），因为完全二叉树的节点数量满足 $2^0 + 2^1 + ... + 2^h = n$，其中 h 是高度。

2. **链式二叉树**（最大）：
   - 这是最坏的情况，即所有的节点都只有一个子节点，形成一条直线。
   - 在这种情况下，树的高度是最大的，等于 n，因为每个节点都加在前一个节点之上。

## 2-16

![image-20241106171644930](https://gitee.com/chen-houchao/images/raw/master/image-20241106171644930.png)

D

第一层：C

第二层：DFB

第三层：AE错误，因为第二层从D开始，所以第三层必须是与D相连的E开头，即**EA**

D选项应为：**CDFBEA**

## 2-17

![image-20241106171650902](https://gitee.com/chen-houchao/images/raw/master/image-20241106171650902.png)

B

A和D选项第一步就错误，第一步只能是从A节点开始

C选项第三个的D节点错误，必须还有C节点在D节点前面

## 2-18

![image-20241106171656696](https://gitee.com/chen-houchao/images/raw/master/image-20241106171656696.png)

D

具体步骤如下：

1. S：将1入栈。
2. X：将1出栈。
3. S：将2入栈。
4. S：将3入栈。
5. X：将3出栈。
6. S：将4入栈。
7. X：将4出栈。
8. X：将2出栈。

## 2-19

![image-20241106171702154](https://gitee.com/chen-houchao/images/raw/master/image-20241106171702154.png)

B

假设某个带头结点的单链表的头指针为 `head`，则判定该表为空表的条件是 `head->next == NULL`。因为带头结点的单链表中，头结点（`head`）本身并不存储有效数据，它只是一个指向链表第一个有效节点的指针。如果 `head->next` 为空，说明链表中没有有效节点，链表为空。

## 2-20

![image-20241106171707308](https://gitee.com/chen-houchao/images/raw/master/image-20241106171707308.png)

C

要将普通的中缀表达式转换为后缀表达式（也称为逆波兰表示法，RPN），可以使用一种名为“Shunting Yard”的算法，这是由计算机科学家Edsger Dijkstra发明的。以下是步骤：

1. **初始化两个栈**：一个操作符栈和一个输出栈。
2. **从左到右遍历输入表达式中的每个字符**：
   - **操作数（数字或变量）**：直接放入输出栈。
   - **左括号**：放入操作符栈。
   - **右括号**：从操作符栈中弹出操作符，并将它们放入输出栈，直到遇到左括号（左括号不放入输出栈）。
   - **操作符**：处理操作符时，需要考虑操作符的优先级和栈中的其他操作符。
     - 当操作符栈非空且栈顶操作符的优先级高于或等于当前操作符时，将栈顶操作符弹出并放入输出栈。
     - 将当前操作符压入操作符栈。
3. **处理完所有字符后**：如果操作符栈中还有操作符，则将它们依次弹出并放入输出栈。

最后，输出栈中的顺序即为后缀表达式。

## 2-21

![image-20241106171713652](https://gitee.com/chen-houchao/images/raw/master/image-20241106171713652.png)

D

在栈的操作中，元素是先进后出的。因此，如果一个序列 in 是入栈序列，其对应的出栈序列 out 可以是 in 的倒序。例如，如果入栈顺序是 [1, 2, 3]，那么出栈顺序可以是 [3, 2, 1]，它们是互为倒序的。

## 2-22

![image-20241106171719203](https://gitee.com/chen-houchao/images/raw/master/image-20241106171719203.png)

D

I. 大部分元素已有序：直接插入排序在数据已经基本有序的情况下效率很高。

II. 待排序元素数量很少：直接插入排序在小数据集上的性能优于快速排序，因为它的开销较低。

III. 要求空间复杂度为O(1)：直接插入排序是就地排序算法，不需要额外的空间。空间排序的空间复杂度为**O(logn)**。

IV. 要求排序算法是稳定的：直接插入排序是稳定排序，而快速排序通常不是稳定排序。

# 多选题

## 3-1

![image-20241106171726376](https://gitee.com/chen-houchao/images/raw/master/image-20241106171726376.png)

ABC

面向对象程序设计的三大特性：**封装**、**继承**、**多态**

## 3-2

![image-20241106171734231](https://gitee.com/chen-houchao/images/raw/master/image-20241106171734231.png)

BC

要注意到`switch`语句中`case`带有`break`和不带有`break`的区别。题目中没有`break`，不管`choice`为什么值最后`price`的值都为**0.0**。知道了这一点再看各个选项哪个不是使得`price`始终为**0.0**的就可以得到答案。

## 3-3

![image-20241106171740141](https://gitee.com/chen-houchao/images/raw/master/image-20241106171740141.png)

ABC

A. 自然语言：用日常语言描述算法的步骤，使其容易理解。

B. 伪代码：用类似编程语言的结构来描述算法，方便程序员理解和实现。

C. 流程图：用图形化的方式展示算法的流程和各个步骤之间的关系，直观且清晰。

## 3-4

![image-20241106171744874](https://gitee.com/chen-houchao/images/raw/master/image-20241106171744874.png)

ACD

**唯一的开始结点和唯一的终端结点（选项A）**：

- 在非空线性表中，总是有一个开始结点（头结点）和一个终端结点（尾结点）。头结点是表的第一个元素，尾结点是表的最后一个元素。这是线性表的基本特征之一，确保线性表只有一个明确的起点和终点。

**不能拥有多个开始结点和多个终端结点（选项B）**：

- 如果线性表有多个开始结点或者多个终端结点，那么它就不再是一个线性的结构，而可能是树形结构或图形结构。因此，选项B不正确。

**每个结点只有一个前驱结点（选项C）**：

- 除了头结点之外，线性表中的每个结点都只有一个前驱结点。前驱结点指的是在当前结点之前的那个结点。这一特性确保了线性表的每个结点都是有序的。

**每个结点只有一个后继结点（选项D）**：

- 除了尾结点之外，线性表中的每个结点都只有一个后继结点。后继结点指的是在当前结点之后的那个结点。这一特性同样确保了线性表的有序性。

## 3-5（？）

![image-20241106171750205](https://gitee.com/chen-houchao/images/raw/master/image-20241106171750205.png)

AC?（貌似是官方答案）

自我观点：

A正确。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。

B错误。假设我们有以下二叉树：

```
    A
   / \
  B   C
   \
    D
```

这个二叉树的中序遍历（In-order）序列是：`B D A C`

这个二叉树的后序遍历（Post-order）序列是：`D B C A`

在这个二叉树中，节点 `B` 是某子树的叶子节点，并且在中序遍历序列中，`B` 是该子树的第一个节点（仅针对左子树来看）。然而，在后序遍历序列中，`B` 不是该子树的第一个节点，而是 `D` 才是该子树的第一个节点。

C错误。已知二叉树的前序遍历和后序遍历虽然不能唯一确定树，但是知道树的根节点是哪一个。

D正确。在前序遍历中，根结点首先访问，然后是左子树的所有结点，最后是右子树的所有结点。因此，任何结点的子树的所有结点都直接跟在该结点之后。

## 3-6

![image-20241106171756078](https://gitee.com/chen-houchao/images/raw/master/image-20241106171756078.png)

ABE

A. 冒泡排序：冒泡排序在排序过程中只使用了常数级别的额外空间，因此空间复杂度是 O(1)。

B. 选择排序：选择排序同样只需要常数级别的额外空间，用于临时变量交换，因此空间复杂度也是 O(1)。

C. 归并排序：归并排序在合并两个有序序列时需要额外的辅助数组，其空间复杂度是 O(n)，而不是 O(1)。

D. 快速排序：快速排序的额外空间复杂度取决于**递归调用的深度**。最坏的情况下会到达O(n)。一般情况下，快速排序的空间复杂度是 O(log n)，但不是 O(1)。 

E. 堆排序：堆排序在排序过程中只使用了常数级别的额外空间来维护堆结构，因此空间复杂度是 O(1)。

因此，额外空间复杂度为 O(1) 的排序算法是 **A. 冒泡排序**、**B. 选择排序** 和 **E. 堆排序**。

## 3-7

![image-20241106171803366](https://gitee.com/chen-houchao/images/raw/master/image-20241106171803366.png)

ABC

A. 访问第 i 个数据元素：因为链表是线性结构，访问第 i 个元素需要从头结点开始逐个遍历，直到第 i 个元素，因此时间复杂度为 O(n)。

B. 在第 i (1≤i≤n) 个结点后插入一个新结点：在链表中插入一个新结点同样需要先找到第 i 个结点，而找到第 i 个结点的操作需要 O(n) 的时间，因此整体时间复杂度为 O(n)。

C. 删除第 i (1≤i≤n) 个结点：删除某个结点前需要找到该结点，同样需要 O(n) 的时间，因此删除操作的时间复杂度为 O(n)。

D. 将 n 个元素按升序排序：排序操作一般需要 O(n log n) 的时间复杂度，而非 O(n)，因此不适用于这个选项。

# 函数题

## **6-1 表彰优秀学生（多态）**

分数 15

作者 何振峰

单位 福州大学

学期结束，班主任决定表彰一批学生，已知该班学生数在6至50人之间，有三类学生：普通生，特招运动员，学科专长生，其中学科专长生不超过5人。

主函数根据输入的信息，相应建立GroupA, GroupB, GroupC类对象。

GroupA类是普通生，有2门课程的成绩（均为不超过100的非负整数）；

GroupB类是特招运动员，有2门课程的成绩（均为不超过100的非负整数），1次运动会的表现分，表现分有：A、B、C、D共4等。

GroupC类是学科专长生，有5门课程的成绩（均为不超过100的非负整数）。

表彰人员至少符合以下3个条件中的一个：

（1）2门课程平均分在普通生和特招运动员中，名列第一者。

a.该平均分称为获奖线。

b.存在成绩并列时，则全部表彰，例如某次考试有2人并列第1，则他们全部表彰。

（2）5门课程平均分达到或超过获奖线90%的学科专长生，给予表彰。

（3）2门课程平均分达到或超过获奖线70%的特招运动员，如果其运动会表现分为A，给予表彰。

输入格式：每个测试用例占一行，第一项为类型，1为普通生，2为特招运动员，3为学科专长生, 输入0表示输入的结束。第二项是学号，第三项是姓名。对于普通生来说，共输入5项，第4、5项是课程成绩。对于特招运动员来说，共输入6项，第4、5项是课程成绩，第6项是运动会表现。对于学科专长生来说，共输入8项，第4、5、6、7、8项是课程成绩。

输出时，打印要表彰的学生的学号和姓名。(输出顺序与要表彰学生的输入前后次序一致)

### 函数接口定义：

```c++
以Student为基类，构建GroupA, GroupB和GroupC三个类
```

### 裁判测试程序样例：

```c++
#include<iostream>
#include <string>
using namespace std;

/* 请在这里填写答案 */

int main()
{
    const int Size=50;
    string num, name;
    int i,ty,s1,s2,s3,s4,s5;
    char gs;
    Student *pS[Size];
    int count=0;
    for(i=0;i<Size;i++){
        cin>>ty;
        if(ty==0) break;
        cin>>num>>name>>s1>>s2;
        switch(ty){
             case 1:pS[count++]=new GroupA(num, name, s1, s2); break;
             case 2:cin>>gs; pS[count++]=new GroupB(num, name, s1,s2, gs); break;
             case 3:cin>>s3>>s4>>s5; pS[count++]=new GroupC(num, name, s1,s2,s3,s4,s5); break;
        }            
    }
    for(i=0;i<count;i++) {
        pS[i]->display();
        delete pS[i];
    }
    return 0;
}
```

### 输入样例：

```in
1 001 AAAA 96 80
2 009 BBB 82 75 A
1 007 CC 100 99
3 012 CCCC 97 95 90 99 93
1 003 DDD 62 50
1 022 ABCE 78 92
2 010 FFF 45 40 A
3 019 AAA 93 97 94 82 80
0
```

### 输出样例：

```out
009 BBB
007 CC
012 CCCC
```

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

### 代码

```C++
static double maxScore = -1.0;
class Student
{
public:
    string num, name;
    int s1, s2;
    virtual void display() = 0;
};
class GroupA : public Student
{
public:
    GroupA()
    {
    }
    GroupA(string num, string name, int s1, int s2)
    {
        if (maxScore < (s1 + s2) * 1.0 / 2)
            maxScore = (s1 + s2) * 1.0 / 2;
        this->num = num;
        this->name = name;
        this->s1 = s1;
        this->s2 = s2;
    }
    void display()
    {
        if ((this->s1 + this->s2) * 1.0 / 2 == maxScore)
        {
            cout << this->num << " " << this->name << endl;
        }
    }
};
class GroupB : public Student
{
public:
    char gs;
    GroupB()
    {
    }
    GroupB(string num, string name, int s1, int s2, char gs)
    {
        if (maxScore < (s1 + s2) * 1.0 / 2)
            maxScore = (s1 + s2) * 1.0 / 2;
        this->num = num;
        this->name = name;
        this->s1 = s1;
        this->s2 = s2;
        this->gs = gs;
    }
    void display()
    {
        if (((this->s1 + this->s2) * 1.0 / 2 == maxScore) || ((this->gs == 'A') && ((this->s1 + this->s2) * 1.0 / 2) > (0.7 * maxScore)))
        {
            cout << this->num << " " << this->name << endl;
        }
    }
};

class GroupC : public Student
{
public:
    int s3, s4, s5;
    GroupC()
    {
    }
    GroupC(string num, string name, int s1, int s2, int s3, int s4, int s5)
    {
        this->num = num;
        this->name = name;
        this->s1 = s1;
        this->s2 = s2;
        this->s3 = s3;
        this->s4 = s4;
        this->s5 = s5;
    }
    void display()
    {
        if ((this->s1 + this->s2 + this->s3 + this->s4 + this->s5) * 1.0 / 5 >= maxScore * 0.9)
        {
            cout << this->num << " " << this->name << endl;
        }
    }
};

```

## **6-2 工作备忘录的生成（链表）**

分数 15

作者 何振峰

单位 福州大学

每天都要处理很多事务，为了更好地安排工作，希望在每天开始工作前，根据工作记录，生成工作备忘录。首先输入工作记录数（大于0的一个整数），再逐条输入各条工作记录，每条工作记录包括：工作名，开始时间，结束时间。假设每项工作的开始时间均小于它的结束时间，并且各项工作的开始时间互不相同。

我们的工作是需要把这些工作记录按开始时间排序并输出，在输出时，如果某项工作与若干项工作冲突（在做该项工作时，需要同时做其它工作），则在该工作名前加'*'。

### 函数接口定义：

```c++
Node* add(Node *, Node *);
void display(Node *);
```

### 裁判测试程序样例：

```c++
#include<iostream>
#include <string>
using namespace std;
struct Node{
    string name;
    int start;
    int end;
    Node *next;
};
Node* add(Node *, Node *);
void display(Node *);
bool check(Node *head)
{
    if(head==NULL || head->next==NULL) return true;
    Node *p=head->next;
    if(head->start > p->start) return false;
    return check(p);
}
int main()
{
    Node *head=NULL, *p;
    int i, repeat;
    cin>>repeat;
    for(i=0;i<repeat;i++){
        p = new Node;
        cin>>p->name>>p->start>>p->end;
        p->next=NULL;
        head = add(head, p);
    }
    if(!check(head)) cout<<"ERROR"<<endl;
    display(head);
    return 0;
}

/* 请在这里填写答案 */
```

### 输入样例：

```in
4
aaa 19 20
ccc 169 200
ddd 153 170
bbb 20 111
```

### 输出样例：

```out
aaa 19 20
bbb 20 111
*ddd 153 170
*ccc 169 200
```

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

### 代码

```C++

Node *add(Node *head, Node *p)
{
    if (head == NULL)
        return p;
    Node *tempNode = head;
    if (p->start < tempNode->start)
    {
        p->next = head;
        return p;
    }
    while (tempNode->next)
    {
        if (p->start > tempNode->start && p->start < tempNode->next->start)
        {
            p->next = tempNode->next;
            tempNode->next = p;
            return head;
        }
        tempNode = tempNode->next;
    }
    tempNode->next = p;
    return head;
}

bool ifCollide(Node *head, Node *p)
{
    Node *tempNode = head;
    while (tempNode)
    {
        if (tempNode != p)
        {
            if (p->start > tempNode->start && p->start < tempNode->end)
                return true;
            if (p->end > tempNode->start && p->end < tempNode->end)
                return true;
            if (tempNode->start > p->start && tempNode->start < p->end)
                return true;
            if (tempNode->end > p->start && tempNode->end < p->end)
                return true;
        }
        tempNode = tempNode->next;
    }
    return false;
}
void display(Node *head)
{
    Node *tempNode = head;
    while (tempNode)
    {
        if (ifCollide(head, tempNode))
            cout << "*" << tempNode->name << " " << tempNode->start << " " << tempNode->end << endl;
        else
            cout << tempNode->name << " " << tempNode->start << " " << tempNode->end << endl;
        tempNode = tempNode->next;
    }
}
```

## **6-3 学生排名表（析构函数）**

分数 15

作者 何振峰

单位 福州大学

现在输入一批学生（人数大于0且不超过100）的名次和他们的姓名。要求按名次输出每个人的排名。

输入格式：每行为一个学生的信息，共两项，第一项为排名（为正整数，且任意两名学生的排名均不同），第二项为学生姓名。当输入－1时，表示输入结束。

输出格式：按名次输出学生姓名，每行一个。

### 函数接口定义：

```c++
main函数的一部分。
```

### 裁判测试程序样例：

```c++
#include <iostream>
#include <string>
using namespace std;
class Student{
    int rank;
    string name;
    public:
        int getRank(){return rank;    }
        Student(string name, int rank):name(name), rank(rank){    }
        ~Student(){ cout<<name<<endl;}
};
int main(){
    int rank, count=0;
    const int SIZE=100;
    Student *pS[SIZE];
    string name;
    cin>>rank;
    while(count<SIZE && rank>0){
        cin>>name;
        pS[count++]= new Student(name, rank);
        cin>>rank;
    }

/* 请在这里填写答案 */

    return 0;
}
```

### 输入样例：

```in
1 Jack
5 Peter
2 Alice
6 Kate
52 Mike
-1
```

### 输出样例：

```out
Jack
Alice
Peter
Kate
Mike
```

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

### 代码

```C++
    for (int i = 0; i < count; i++)
    {
        for (int j = i + 1; j < count; j++)
        {
            if (pS[i]->getRank() > pS[j]->getRank())
            {
                Student *temp = pS[i];
                pS[i] = pS[j];
                pS[j] = temp;
            }
        }
    }
    for (int i = 0; i < count; i++)
    {
        delete pS[i];
    }

```

## **6-4 2017final友元函数之全班同学的平均绩点**

分数 15

作者 east

单位 福州大学

一个学生类，有三个私有成员：名字name、课程学分指针score、课程成绩指针grade。定义一个友元函数，求全班同学的平均绩点。单门课程的学分绩点=学分*绩点=学分*(成绩/10-5) ;  全班同学的平均绩点是 所有同学的全部课程的学分绩点之和/所有同学学分数之和。单个同学的课程数不超过100门。全班同学人数不超过100名。

输入说明：

输入若干行。 

每行一个学生的信息：第一个输入是学生的名字，第二个输入是第一门课程的学分，第三个输入是第一门课程的成绩，第四个输入是第二门课程的学分，第五个输入是第二门课程的成绩，以此类推，最后以-1表示该行输入结束。每个学生的课程数不超过100门。

最后以 no 表示输入结束。

输出一行，即该全班同学的平均绩点。

### 函数接口定义：

```c++
这是求全部同学平均绩点的友元函数的声明：
friend double averagegrade(student *stu, int count)
```

其中 `*stu` 和 `count` 都是用户传入的参数。 `*stu` 是传入的学生对象数组的首指针，`count`是全班学生数量。

### 裁判测试程序样例：

```c++
#include<iostream>
#include<string>
using namespace std;
class student{
   private:
      double *grade;
      double *score;
      string name;
public:
      student( )
     {
      grade=NULL;
      score=NULL;
      }
      student(string n, double *g, double *s)
      {
            name=n;
            grade=g;
            score=s;
       }
     friend double averagegrade(student *stu, int count);
};
/* 请在这里填写答案 */


int main()
{
   student stu[100];
   double s[100][100], g[100][100];
   int count=0;
   string n;
   for(int i=0;i<100;i++)
   {
         cin>>n;
         if(n=="no") break;
         count++;
         for(int j=0;j<100;j++)
        {
            cin>>s[i][j];
            if(s[i][j]==-1) break;
            cin>>g[i][j];
        }
       stu[i]=student(n, g[i], s[i]);
   }
   cout<<averagegrade(stu, count);
   return 0;
}
```

### 输入样例：

```in
bob 3 90 2 68.5 2.5 50 -1
andy 3 80 2 77 -1
no
```

### 输出样例：

```out
2.408
```

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

### 代码

```C++
double averagegrade(student *stu, int count)
{
    double sumGpa = 0.0;
    double sumCredit = 0.0;
    for (int i = 0; i < count; i++)
    {
        for (int j = 0; stu[i].score[j] != -1; j++)
        {
            sumGpa += stu[i].score[j] * (stu[i].grade[j] / 10 - 5);
            sumCredit += stu[i].score[j];
        }
    }
    if (sumGpa == 0 || sumCredit == 0)
        return 0;
    return sumGpa / sumCredit;
}
```

## **6-5 2017Final 乐观的中考生**

分数 15

作者 何振峰

单位 福州大学

作为参加首届全省统一中考的学生，小林同学的压力非常大。每天老师都会布置很多批作业，每批作业具有相同的优先值（不同批的任务的优先值不一样），由若干个不同的任务组成，每个任务都有唯一的编号，小林同学会把每批作业先按照编号顺序整理好，然后按照这批作业的优先值，放入活页夹里。接下来，她将按照任务在活页夹的顺序依次把作业完成。

但近期情况有改变了：妈妈给她生了一个弟弟，所以她要时不时帮妈妈照看一下他。令她欣慰的是：可爱的弟弟非常乖，每次吵闹的时间和程度都是可以预期的。因此她可以确定当前能用于完成作业的最长时间，每项任务的可持续时间（最短时间和最长时间，其中设置最短时间是因为连续的学习时间非常宝贵，所以在预期弟弟会安静较长时间时，她要把时间放在那些工作量较大的任务上），然后按符合条件的任务在活页夹中的顺序来完成。

林同学非常乐观，当她整理完一批作业，或者结束一次工作时，都会找出该批作业的第三个任务或者活页夹中的第三个任务（因为3是她的幸运数字）看一下，如果任务数少于3个，她会愉快地说一声"OK"。

现在要输出林同学看到的任务和她说的"OK"。

输入时，每次输入一行：

（1）如果该行的第一个数字是正数N时，说明新来了一批任务，这批任务由N个任务构成。第二个数字是该批任务的优先值，为不超过10000的正整数，从第三个数字开始的2*N个数字是顺序的N个任务的信息，前面一个是任务号（不超过10000的正整数），后一个是任务的持续时间（不超过200的正整数）。（每批任务在输入时，已经按照编号排好序了，因此不需要考虑按顺序号的从小到大排序过程，只好按任务来到的顺序简单整理好，放进一个小链表就可以了。）。然后再将这批任务根据优先值插入活页夹（大链表）。

（2）如果该行的第一个数字是负数，则说明现在可以做作业了，接下来会输入三个数字，第一个数字是单项任务的最短持续时间mi，第二个数字是单项任务的最长持续时间ma,最后一个数字是本次工作的最长持续时间load.

（3）如果该行的第一个数字是0，则结束。

### 函数接口定义：

```c++
Task* getBatch(int m);   //接收一批任务，该批任务共有m项任务
Task* addBatch(Task *head, Task *h);//将h指向的小链表插入head指向的大链表，并返回新的大链表首指针。
void display(Task *head, int m);//输出第m项任务的信息，或者输出OK
Task* study(Task*head, int mi, int ma, int load);
//mi是本次学习过程中，所学习的各个单项任务的最短持续时间约束，ma是单项任务的最长持续时间约束, load是本次学习过程的最长持续时间
```

### 裁判测试程序样例：

```c++
#include <iostream>
using namespace std;
struct Task{
    int ID;//任务编号
    int key;//任务优先级
    int load;//任务持续时间
    Task *next;
};

/* 请在这里填写答案 */

void del(Task* head){//删除链表
    if(head==NULL) return;
    del(head->next);
    delete head;
}
const int K=3;//幸运数字
int main(){
    int count, mi, ma, load;
    Task *head=NULL, *h;
    cin>>count;//输入行的第一个数字
    while(count!=0){
        if(count>0){   //新添加count个任务
            h=getBatch(count);//构建链表，并将首指针返回给h
            display(h, K);//显示小链表的第K个任务或输出OK
            head=addBatch(head, h);//将小链表加入大链表，并将首指针返回
        }else{
            cin>>mi>>ma>>load;
            head=study(head, mi, ma, load);
            display(head,K);//显示大链表的第K个任务或输出OK
        }
        cin>>count;        
    }
    del(head);
    return 0;
}
```

### 输入样例：

```in
4 12 101 5 102 3 103 6 104 7
2 22 105 12 106 8
1 9 107 9
-1 5 10 25
0
```

### 输出样例：

输出时先输出任务号，再输出任务的优先级，最后输出时间。如果没有可输出的任务，则输出“OK”。

```
103 12 6
OK
OK
105 22 12
```

说明：

（1）输入：4 12 101 5 102 3 103 6 104 7后，

子链（即小链表)共有四项任务101,102,103和104，其中第三项任务是103, 所以输出它的编号，优先值和时间103 12 6

将子链加入活页夹（大链表）后，活页夹中也是四项任务

（2）输入：2 22 105 12 106 8后

子链中共有两项任务105和106，找不到第三项，所以输出OK。

加入活页夹中，此时活页夹中共有六项任务：101,102,103,104,105,106

（3）输入：1 9 107 9后

子链中共有一项任务，所以输出OK。

加入活页夹中，此时活页夹中共有七项任务，顺序为：107,101,102,103,104,105,106

(4)-1 5 12 25

则顺序完成活页夹中时间在5和12之间的任务，最多持续时间为20

第一项任务107，持续时间为9，符合要求，完成该项任务后，剩余时间为16

第二项任务101, 持续时间为5, 符合要求，完成该项任务后，剩余时间为11
第三项任务102，持续时间为3, 不符合最低持续时间为5的要求，直接忽略。

第四项任务103,持续时间为6，符合要求，完成该项任务后，剩余时间为5。

接下来的任务都没有足够时间完成，所以此时活页夹中剩余四项任务，为：102,104,105,106

此时输出活页夹的第三项任务信息：105 22 12

(5)输入0，结束

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

### 代码

```C++
Task *getBatch(int m) // 接收一批任务，该批任务共有m项任务
{
    int tempKey; // 优先级
    cin >> tempKey;
    Task *head = new Task; // 第一个任务，头指针
    head->next = NULL;
    head->key = tempKey;
    cin >> head->ID >> head->load;
    Task *rearTask = head;
    for (int i = 1; i < m; i++) // 少一个头
    {
        Task *tempTask = new Task;
        tempTask->key = tempKey;
        tempTask->next = NULL;
        cin >> tempTask->ID >> tempTask->load;
        rearTask->next = tempTask;
        rearTask = rearTask->next;
    }
    return head;
}

Task *addBatch(Task *head, Task *h) // 将h指向的小链表插入head指向的大链表，并返回新的大链表首指针。
{
    if (h == NULL)
        return head;
    if (head == NULL)
        return h;
    if (h->key < head->key) {
        Task *tempTask = h;
        while (tempTask->next != NULL) {
            tempTask = tempTask->next;
        }
        tempTask->next = head;
        return h;
    }
    Task *tempTask = head;
    while (tempTask->next != NULL) {
        if (tempTask->next->key > h->key) {
            Task *tempH = h;
            while (tempH->next != NULL) {
                tempH = tempH->next;
            }
            tempH->next = tempTask->next;
            tempTask->next = h;
            return head;
        }
        tempTask = tempTask->next;
    }
    tempTask->next = h;
    return head;
}

void display(Task *head, int m) // 输出第m项任务的信息，或者输出OK
{
    if (head == NULL)
    {
        cout << "OK" << endl;
        return;
    }
    Task *tempTask = head;
    for (int i = 1; i < m; i++)
    {
        if (tempTask->next == NULL)
        {
            cout << "OK" << endl;
            return;
        }
        tempTask = tempTask->next;
    }
    cout << tempTask->ID << " " << tempTask->key << " " << tempTask->load << endl;
    return;
}

Task *study(Task *head, int mi, int ma, int load) // mi是本次学习过程中，所学习的各个单项任务的最短持续时间约束，ma是单项任务的最长持续时间约束, load是本次学习过程的最长持续时间
{
    if (head == NULL)
        return NULL;
    Task *tempTask = head;
    while (tempTask->next != NULL) {
        if (tempTask->load >= mi && tempTask->load <= ma && load >= tempTask->load) {
            load -= tempTask->load;
            head = head->next;
            tempTask = head;
        } else {
            break;
        }
    }
    if (tempTask->next == NULL) {
        if (tempTask->load >= mi && tempTask->load <= ma && load >= tempTask->load) {
            return NULL;
        } else {
            return head;
        }
    }
    Task *prevTask = head, *currTask = head->next;
    while (currTask != NULL) {
        if (currTask->load >= mi && currTask->load <= ma && load >= currTask->load) {
            load -= currTask->load;
            prevTask->next = currTask->next;
            currTask = currTask->next;
        } else {
            prevTask = prevTask->next;
            currTask = currTask->next;
        }
    }
    return head;
}

```

# 编程题

## **7-1 比较大小**

分数 15

作者 杨起帆

单位 浙大城市学院

本题要求将输入的任意3个整数从小到大输出。

### 输入格式:

输入在一行中给出3个整数，其间以空格分隔。

### 输出格式:

在一行中将3个整数从小到大输出，其间以“->”相连。 

### 输入样例:

```in
4 2 8
```

### 输出样例:

```out
2->4->8
```

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

int main()
{
    vector<int>numBag;
    for(int i=0;i<3;i++)
    {
        int inputNum;
        cin>>inputNum;
        numBag.push_back(inputNum);
    }
    sort(numBag.begin(), numBag.end());
    for(int i=0;i<numBag.size()-1;i++)
    {
        cout<<numBag[i]<<"->";
    }
    cout<<numBag[numBag.size()-1];
    return 0;
}
```

## **7-2 计算指数**

分数 15

作者 陈越

单位 浙江大学

真的没骗你，这道才是简单题 —— 对任意给定的不超过 10 的正整数 *n*，要求你输出 2*n*。不难吧？

### 输入格式：

输入在一行中给出一个不超过 10 的正整数 *n*。

### 输出格式：

在一行中按照格式  `2^n = 计算结果`  输出 2*n* 的值。

### 输入样例：

```in
5
```

### 输出样例：

```out
2^5 = 32
```

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

int pow(int x)
{
    if (x == 1)
        return 2;
    else
        return 2 * pow(x - 1);
}
int main()
{
    int n;
    cin >> n;
    cout << "2^" << n << " = " << pow(n);
    return 0;
}
```

## **7-3 计算阶乘和**

分数 15

作者 陈越

单位 浙江大学

对于给定的正整数*N*，需要你计算 *S*=1!+2!+3!+...+*N*!。

### 输入格式：

输入在一行中给出一个不超过10的正整数*N*。

### 输出格式：

在一行中输出*S*的值。

### 输入样例：

```in
3
```

### 输出样例：

```out
9
```

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

long long func(long long inputNum)
{
    if (inputNum == 1)
        return 1;
    else
        return inputNum * (func(inputNum - 1));
}

int main()
{
    long long inputNum;
    long long resultNum = 0;
    cin >> inputNum;
    // cout << func(inputNum);
    for (int i = 1; i <= inputNum; i++)
    {
        resultNum += func(i);
    }
    cout << resultNum;
    return 0;
}
```

## **7-4 跟奥巴马一起画方块**

分数 15

作者 陈越

单位 浙江大学

美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！

### 输入格式：

输入在一行中给出正方形边长*N*（3≤*N*≤21）和组成正方形边的某种字符`C`，间隔一个空格。

### 输出格式：

输出由给定字符`C`画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的50%（四舍五入取整）。

### 输入样例：

```in
10 a
```

### 输出样例：

```out
aaaaaaaaaa
aaaaaaaaaa
aaaaaaaaaa
aaaaaaaaaa
aaaaaaaaaa
```

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;


int main()
{
    int lengthNum;
    cin>>lengthNum;
    double temp = lengthNum*1.0/2;
    int widthNum = round(temp);
    char inputChar;
    cin>>inputChar;
    for(int i = 1;i<=widthNum; i++)
    {
        for(int j=1; j<=lengthNum; j++)
        {
            cout<<inputChar;
        }
        cout<<endl;
    }
    return 0;
}
```

## **7-5 计算天数**

分数 15

作者 沈睿

单位 浙江大学

本题要求编写程序计算某年某月某日是该年中的第几天。

### 输入格式:

输入在一行中按照格式“yyyy/mm/dd”（即“年/月/日”）给出日期。注意：闰年的判别条件是该年年份能被4整除但不能被100整除、或者能被400整除。闰年的2月有29天。 

### 输出格式:

在一行输出日期是该年中的第几天。

### 输入样例1:

```in
2009/03/02
```

### 输出样例1:

```out
61
```

### 输入样例2:

```
2000/03/02
```

### 输出样例2:

```
62
```

**鸣谢湖北汽车工业学院袁科老师、用户潘明智补充数据！**

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```C++
#include <bits/stdc++.h>
using namespace std;

// 判断是否为闰年
bool ifRun(int year)
{
    if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)
        return true;
    return false;
}

int main()
{
    int year, month, day;
    scanf("%d/%d/%d", &year, &month, &day);
    int resultNum = 0;
    for (int i = 1; i < month; i++)
    {
        switch (i)
        {
        case 1:
        case 3:
        case 5:
        case 7:
        case 8:
        case 10:
        case 12:
            resultNum += 31;
            break;
        case 4:
        case 6:
        case 9:
        case 11:
            resultNum += 30;
            break;
        case 2:
            switch (ifRun(year))
            {
            case true:
                resultNum += 29;
                break;
            default:
                resultNum += 28;
                break;
            }

            break;
        }
    }
    resultNum += day;
    cout << resultNum;
    return 0;
}

```

## **7-6 然后是几点**

分数 15

作者 翁恺

单位 浙江大学

有时候人们用四位数字表示一个时间，比如 `1106` 表示 11 点零 6 分。现在，你的程序要根据起始时间和流逝的时间计算出终止时间。

读入两个数字，第一个数字以这样的四位数字表示当前时间，第二个数字表示分钟数，计算当前时间经过那么多分钟后是几点，结果也表示为四位数字。当小时为个位数时，没有前导的零，例如 5 点 30 分表示为 `530`；0 点 30 分表示为 `030`。注意，第二个数字表示的分钟数可能超过 60，也可能是负数。

### 输入格式：

输入在一行中给出 2 个整数，分别是四位数字表示的起始时间、以及流逝的分钟数，其间以空格分隔。注意：在起始时间中，当小时为个位数时，没有前导的零，即 5 点 30 分表示为 `530`；0 点 30 分表示为 `030`。流逝的分钟数可能超过 60，也可能是负数。

### 输出格式：

输出不多于四位数字表示的终止时间，当小时为个位数时，没有前导的零。题目保证起始时间和终止时间在同一天内。

### 输入样例：

```in
1120 110
```

### 输出样例：

```out
1310
```

**鸣谢燕山大学穆运峰老师、用户任钰补充数据！**

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;

int main()
{

    // 定义初始数据
    int start, interval;
    cin >> start >> interval;
    int minTemp = (start / 100) * 60 + (start % 100) + interval;
    int result = (minTemp / 60) * 100 + (minTemp % 60);
    if (result < 100)
        cout << "0" << result;
    else
        cout << result;
    return 0;
}
```

## **7-7 人民币兑换**

分数 15

作者 林颖贤

单位 浙江大学

1元5角钱人民币兑换5分、2分和1分的硬币（每一种都要有）共100枚，会有很多种兑换方案。请编写程序给出各种兑换方案。

### 输入格式:

输入为一个正整数n，表示要求输出前n种可能的方案。方案的顺序，是按照5分硬币从少到多排列的。

### 输出格式:

显示前n种方案中5分、2分、1分硬币各多少枚。每行显示一种方案，数字之间空一格，最后一个数字后没有空格。

注意：如果全部方案不到n种，就顺序输出全部可能的方案。

### 输入样例:

```in
5
```

### 输出样例:

```out
1 46 53  
2 42 56  
3 38 59  
4 34 62  
5 30 65
```

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;

int main()
{

    int n;
    cin >> n;
    int y = 46;
    for (int x = 1; x <= n; x++)
    {
        while (y > 0)
        {
            if ((x * 5) + (y * 2) < 150)
            {
                cout << x << " " << y << " " << 150 - 5 * x - 2 * y << endl;
                y -= 4;
                break;
            }
        }
    }
    return 0;
}
```

## **7-8 正整数A+B**

分数 15

作者 陈越

单位 浙江大学

题的目标很简单，就是求两个正整数`A`和`B`的和，其中`A`和`B`都在区间[1,1000]。稍微有点麻烦的是，输入并不保证是两个正整数。

### 输入格式：

输入在一行给出`A`和`B`，其间以空格分开。问题是`A`和`B`不一定是满足要求的正整数，有时候可能是超出范围的数字、负数、带小数点的实数、甚至是一堆乱码。

注意：我们把输入中出现的第1个空格认为是`A`和`B`的分隔。题目保证至少存在一个空格，并且`B`不是一个空字符串。

### 输出格式：

如果输入的确是两个正整数，则按格式`A + B = 和`输出。如果某个输入不合要求，则在相应位置输出`?`，显然此时和也是`?`。

### 输入样例1：

```in
123 456
```

### 输出样例1：

```out
123 + 456 = 579
```

### 输入样例2：

```
22. 18
```

### 输出样例2：

```
? + 18 = ?
```

### 输入样例3：

```
-100 blabla bla...33
```

### 输出样例3：

```
? + ? = ?
```

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;

int main()
{
    string inputNum;
    getline(cin, inputNum);
    int namespace1 = -1;
    bool ifValidA = true, ifValidB = true;
    int aNum = 0, bNum = 0;
    // 寻找第一个空格
    for (int i = 0; i < inputNum.size(); i++)
    {
        if (inputNum[i] == ' ')
        {
            namespace1 = i;
            break;
        }
    }
    for (int i = 0; i < namespace1; i++)
    {
        if (inputNum[i] < '0' || inputNum[i] > '9')
        {
            ifValidA = false;
            break;
        }
        else
        {
            aNum = aNum * 10 + (inputNum[i] - '0');
        }
    }
    for (int i = namespace1 + 1; i < inputNum.size(); i++)
    {
        if (inputNum[i] < '0' || inputNum[i] > '9')
        {
            ifValidB = false;
            break;
        }
        else
        {
            bNum = bNum * 10 + (inputNum[i] - '0');
        }
    }
    // 判断两个数字是否在规定的范围[1,1000]内
    if (aNum < 1 || aNum > 1000)
        ifValidA = false;
    if (bNum < 1 || bNum > 1000)
        ifValidB = false;
    // 开始输出
    if (ifValidA)
    {
        cout << aNum;
    }
    else
    {
        cout << "?";
    }
    cout << " + ";
    if (ifValidB)
    {
        cout << bNum;
    }
    else
    {
        cout << "?";
    }
    if (!ifValidA || !ifValidB)
    {
        cout << " = ?";
    }
    else
        cout << " = " << aNum + bNum;
    return 0;
}
```

## **7-9 个位数统计**

分数 15

作者 陈越

单位 浙江大学

给定一个 *k* 位整数 *N*=*d**k*−110*k*−1+⋯+*d*1101+*d*0 (0≤*d**i*≤9, *i*=0,⋯,*k*−1, *d**k*−1>0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定 *N*=100311，则有 2 个 0，3 个 1，和 1 个 3。

### 输入格式：

每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 *N*。

### 输出格式：

对 *N* 中每一种不同的个位数字，以 `D:M` 的格式在一行中输出该位数字 `D` 及其在 *N* 中出现的次数 `M`。要求按 `D` 的升序输出。

### 输入样例：

```in
100311
```

### 输出样例：

```out
0:2
1:3
3:1
```

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;

int main()
{
    string num;
    cin >> num;
    int numCount[10] = {0};
    for (char i : num)
    {
        int iNum = i - '0';
        numCount[iNum]++;
    }
    for (int i = 0; i <= 9; i++)
    {
        if (numCount[i] != 0)
        {
            cout << i << ":" << numCount[i] << endl;
        }
    }
}
```

## **7-10 考试座位号**

分数 15

作者 陈越

单位 浙江大学

每个 PAT 考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。

### 输入格式：

输入第一行给出一个正整数 *N*（≤1000），随后 *N* 行，每行给出一个考生的信息：`准考证号 试机座位号 考试座位号`。其中`准考证号`由 16 位数字组成，座位从 1 到 *N* 编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。

考生信息之后，给出一个正整数 *M*（≤*N*），随后一行中给出 *M* 个待查询的试机座位号码，以空格分隔。

### 输出格式：

对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用 1 个空格分隔。

### 输入样例：

```in
4
3310120150912233 2 4
3310120150912119 4 1
3310120150912126 1 3
3310120150912002 3 2
2
3 4
```

### 输出样例：

```out
3310120150912002 2
3310120150912119 1
```

代码长度限制

16 KB

时间限制

200 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int N;
    cin >> N;
    unordered_map<int, pair<string, int>> data;
    for (int i = 1; i <= N; i++)
    {
        string tempAdmission;
        int tempSeat1; // 试机座位号码
        int tempSeat2; // 考试座位号码
        cin >> tempAdmission >> tempSeat1 >> tempSeat2;
        data[tempSeat1] = {tempAdmission, tempSeat2};
    }
    // 开始查询
    int M;
    cin >> M;
    while (M--)
    {
        int tempSearch;
        cin >> tempSearch;
        cout << data[tempSearch].first << " " << data[tempSearch].second << endl;
    }
    return 0;
}
```

## **7-11 念数字**

分数 15

作者 翁恺

单位 浙江大学

输入一个整数，输出每个数字对应的拼音。当整数为负数时，先输出`fu`字。十个数字对应的拼音如下：

```
0: ling
1: yi
2: er
3: san
4: si
5: wu
6: liu
7: qi
8: ba
9: jiu
```

### 输入格式：

输入在一行中给出一个整数，如：`1234`。

**提示：整数包括负数、零和正数。**

### 输出格式：

在一行中输出这个整数对应的拼音，每个数字的拼音之间用空格分开，行末没有最后的空格。如
`yi er san si`。

### 输入样例：

```in
-600
```

### 输出样例：

```out
fu liu ling ling
```

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;

string transfer(char i)
{
    switch (i)
    {
    case '-':
        return "fu";
    case '0':
        return "ling";
    case '1':
        return "yi";
    case '2':
        return "er";
    case '3':
        return "san";
    case '4':
        return "si";
    case '5':
        return "wu";
    case '6':
        return "liu";
    case '7':
        return "qi";
    case '8':
        return "ba";
    case '9':
        return "jiu";
    }
}

int main()
{
    string inputNum;
    cin >> inputNum;
    for (int i = 0; i < inputNum.size(); i++)
    {
        if (i != 0)
            cout << " " << transfer(inputNum[i]);
        else
            cout << transfer(inputNum[i]);
    }
    return 0;
}
```

## **7-12 检查密码**

分数 15

作者 陈越

单位 浙江大学

本题要求你帮助某网站的用户注册模块写一个密码合法性检查的小功能。该网站要求用户设置的密码必须由不少于6个字符组成，并且只能有英文字母、数字和小数点 `.`，还必须既有字母也有数字。

### 输入格式：

输入第一行给出一个正整数 N（≤ 100），随后 N 行，每行给出一个用户设置的密码，为不超过 80 个字符的非空字符串，以回车结束。

**注意：** 题目保证不存在只有小数点的输入。

### 输出格式：

对每个用户的密码，在一行中输出系统反馈信息，分以下5种：

- 如果密码合法，输出`Your password is wan mei.`；
- 如果密码太短，不论合法与否，都输出`Your password is tai duan le.`；
- 如果密码长度合法，但存在不合法字符，则输出`Your password is tai luan le.`；
- 如果密码长度合法，但只有字母没有数字，则输出`Your password needs shu zi.`；
- 如果密码长度合法，但只有数字没有字母，则输出`Your password needs zi mu.`。

### 输入样例：

```in
5
123s
zheshi.wodepw
1234.5678
WanMei23333
pass*word.6
```

### 输出样例：

```out
Your password is tai duan le.
Your password needs shu zi.
Your password needs zi mu.
Your password is wan mei.
Your password is tai luan le.
```

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;

bool ifValid(const string &str)
{
    regex pattern1("^[a-zA-Z0-9.]+$");
    regex pattern2("^[a-zA-Z0-9]+$");
    return regex_match(str, pattern1) || regex_match(str, pattern2);
}

bool ifOnlyLetter(const string &str)
{
    regex pattern("^[a-zA-Z.]+$");
    return regex_match(str, pattern);
}

bool ifOnlyNum(const string &str)
{
    regex pattern("^[0-9.]+$");
    return regex_match(str, pattern);
}

string justifyPassword(string password)
{
    if (password.length() < 6)
        return "Your password is tai duan le.";
    else if (!ifValid(password))
        return "Your password is tai luan le.";
    else if (ifOnlyLetter(password))
        return "Your password needs shu zi.";
    else if (ifOnlyNum(password))
        return "Your password needs zi mu.";
    else
        return "Your password is wan mei.";
}

int main()
{
    int N;
    cin >> N;
    getchar();
    while (N--)
    {
        string tempStr;
        getline(cin, tempStr);
        // cout << tempStr.length();
        cout << justifyPassword(tempStr) << endl;
    }
    return 0;
}
```

## **7-13 谁是赢家**

分数 15

作者 陈越

单位 浙江大学

某电视台的娱乐节目有个表演评审环节，每次安排两位艺人表演，他们的胜负由观众投票和 3 名评委投票两部分共同决定。规则为：如果一位艺人的观众票数高，且得到至少 1 名评委的认可，该艺人就胜出；或艺人的观众票数低，但得到全部评委的认可，也可以胜出。节目保证投票的观众人数为奇数，所以不存在平票的情况。本题就请你用程序判断谁是赢家。

### 输入格式：

输入第一行给出 2 个不超过 1000 的正整数 Pa 和 Pb，分别是艺人 a 和艺人 b 得到的观众票数。题目保证这两个数字不相等。随后第二行给出 3 名评委的投票结果。数字 0 代表投票给 a，数字 1 代表投票给 b，其间以一个空格分隔。

### 输出格式：

按以下格式输出赢家：

```
The winner is x: P1 + P2
```

其中 `x` 是代表赢家的字母，`P1` 是赢家得到的观众票数，`P2` 是赢家得到的评委票数。

### 输入样例：

```in
327 129
1 0 1
```

### 输出样例：

```out
The winner is a: 327 + 1
```

**鸣谢安阳师范学院软件学院李栋同学完善测试数据。**

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int voteA, voteB;
    cin >> voteA >> voteB;
    bool refereeVote[3] = {};
    int refereeVoteSum = 0;
    for (int i = 0; i <= 2; i++)
    {
        cin >> refereeVote[i];
        refereeVoteSum += refereeVote[i];
    }
    if (voteA > voteB && (3 - refereeVoteSum > 0))
        // The winner is x : P1 + P2
        cout << "The winner is a: " << voteA << " + " << 3 - refereeVoteSum;
    else
        cout << "The winner is b: " << voteB << " + " << refereeVoteSum;
    return 0;
}
```

## **7-14 不变初心数**

分数 15

作者 陈越

单位 浙江大学

不变初心数是指这样一种特别的数，它分别乘 2、3、4、5、6、7、8、9 时，所得乘积各位数之和却不变。例如 18 就是这样的数：18 的 2 倍是 36，3+6=9；18 的 3 倍是 54，5+4=9；…… 18 的 9 倍是 162，1+6+2=9。对于 18 而言，9 就是它的初心。本题要求你判断任一个给定的数是否有不变的初心。

### 输入格式：

输入在第一行中给出一个正整数 N（≤ 100）。随后 N 行，每行给出一个不超过 105 的正整数。

### 输出格式：

对每个给定的数字，如果它有不变的初心，就在一行中输出它的初心；否则输出 `NO`。

### 输入样例：

```in
4
18
256
99792
88672
```

### 输出样例：

```out
9
NO
36
NO
```

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;

int justifyNum(int tempNum)
{
    int expectedNum;
    for (int i = 2; i <= 9; i++)
    {
        int num = tempNum * i;
        int tempSum = 0;
        while (num > 0)
        {
            tempSum += num % 10;
            num /= 10;
        }
        if (i == 2)
            expectedNum = tempSum;
        else if (tempSum != expectedNum)
        {
            return -1;
        }
    }
    return expectedNum;
}

int main()
{
    int N;
    cin >> N;
    while (N--)
    {
        int tempNum;
        cin >> tempNum;
        if (justifyNum(tempNum) == -1)
            cout << "NO" << endl;
        else
            cout << justifyNum(tempNum) << endl;
    }
    return 0;
}
```

## **7-15 新胖子公式**

分数 15

作者 陈越

单位 浙江大学

根据钱江晚报官方微博的报导，最新的肥胖计算方法为：体重(kg) / 身高(m) 的平方。如果超过 25，你就是胖子。于是本题就请你编写程序自动判断一个人到底算不算胖子。

### 输入格式：

输入在一行中给出两个正数，依次为一个人的体重（以 kg 为单位）和身高（以 m 为单位），其间以空格分隔。其中体重不超过 1000 kg，身高不超过 3.0 m。

### 输出格式：

首先输出将该人的体重和身高代入肥胖公式的计算结果，保留小数点后 1 位。如果这个数值大于 25，就在第二行输出 `PANG`，否则输出 `Hai Xing`。

### 输入样例 1：

```in
100.1 1.74
```

### 输出样例 1：

```out
33.1
PANG
```

### 输入样例 2：

```in
65 1.70
```

### 输出样例 2：

```out
22.5
Hai Xing
```

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;

double justifyNum(double weight, double height)
{
    return weight * 1.0 / (pow(height, 2));
}

int main()
{
    double weight, height;
    cin >> weight >> height;
    cout << fixed << setprecision(1) << justifyNum(weight, height) << endl;
    if (justifyNum(weight, height) > 25)
        cout << "PANG";
    else
        cout << "Hai Xing";
    return 0;
}
```

## **7-16 幸运彩票**

分数 15

作者 陈越

单位 浙江大学

彩票的号码有 6 位数字，若一张彩票的前 3 位上的数之和等于后 3 位上的数之和，则称这张彩票是幸运的。本题就请你判断给定的彩票是不是幸运的。

### 输入格式：

输入在第一行中给出一个正整数 N（≤ 100）。随后 N 行，每行给出一张彩票的 6 位数字。

### 输出格式：

对每张彩票，如果它是幸运的，就在一行中输出 `You are lucky!`；否则输出 `Wish you good luck.`。

### 输入样例：

```in
2
233008
123456
```

### 输出样例：

```out
You are lucky!
Wish you good luck.
```

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int justiceNum;
    cin >> justiceNum;
    for (int k = 1; k <= justiceNum; k++)
    {
        int tempNum;
        cin >> tempNum;
        int numSum1 = 0, numSum2 = 0;
        for (int i = 1; i <= 3; i++)
        {
            numSum1 += tempNum % 10;
            tempNum /= 10;
        }
        for (int i = 1; i <= 3; i++)
        {
            numSum2 += tempNum % 10;
            tempNum /= 10;
        }
        if (numSum1 == numSum2)
            cout << "You are lucky!" << endl;
        else
            cout << "Wish you good luck." << endl;
    }
    return 0;
}
```

## **7-17 降价提醒机器人**

分数 15

作者 DAI, Longao

单位 杭州百腾教育科技有限公司

小 T 想买一个玩具很久了，但价格有些高，他打算等便宜些再买。但天天盯着购物网站很麻烦，请你帮小 T 写一个降价提醒机器人，当玩具的当前价格比他设定的价格便宜时发出提醒。

### 输入格式：

输入第一行是两个正整数 *N* 和 *M* (1≤*N*≤100,0≤*M*≤1000)，表示有 *N* 条价格记录，小 T 设置的价格为 *M*。

接下来 *N* 行，每行有一个实数 *P**i*（−1000.0<*P**i*<1000.0），表示一条价格记录。

### 输出格式：

对每一条比设定价格 *M* 便宜的价格记录 `P`，在一行中输出 `On Sale! P`，其中 `P` 输出到小数点后 1 位。

### 输入样例：

```in
4 99
98.0
97.0
100.2
98.9
```

### 输出样例：

```out
On Sale! 98.0
On Sale! 97.0
On Sale! 98.9
```

代码长度限制

16 KB

Java (javac)

时间限制

600 ms

内存限制

64 MB

其他编译器

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int N, M;
    cin >> N >> M;
    while (N--)
    {
        double nowPrice;
        cin >> nowPrice;
        if (nowPrice < M)
            cout << "On Sale! " << fixed << setprecision(1) << nowPrice << endl;
    }
    return 0;
}
```

## **7-18 胎压监测**

分数 15

作者 陈越

单位 浙江大学

小轿车中有一个系统随时监测四个车轮的胎压，如果四轮胎压不是很平衡，则可能对行车造成严重的影响。

![taiya.JPG](https://images.ptausercontent.com/66539c6c-cd86-4bbb-a15c-d00828719f75.JPG)

让我们把四个车轮 —— 左前轮、右前轮、右后轮、左后轮 —— 顺次编号为 1、2、3、4。本题就请你编写一个监测程序，随时监测四轮的胎压，并给出正确的报警信息。报警规则如下：

- 如果所有轮胎的压力值与它们中的最大值误差在一个给定阈值内，并且都不低于系统设定的最低报警胎压，则说明情况正常，不报警；
- 如果存在一个轮胎的压力值与它们中的最大值误差超过了阈值，或者低于系统设定的最低报警胎压，则不仅要报警，而且要给出可能漏气的轮胎的准确位置；
- 如果存在两个或两个以上轮胎的压力值与它们中的最大值误差超过了阈值，或者低于系统设定的最低报警胎压，则报警要求检查所有轮胎。

### 输入格式：

输入在一行中给出 6 个 [0, 400] 范围内的整数，依次为 1~4 号轮胎的胎压、最低报警胎压、以及胎压差的阈值。

### 输出格式：

根据输入的胎压值给出对应信息：

- 如果不用报警，输出 `Normal`；
- 如果有一个轮胎需要报警，输出 `Warning: please check #X!`，其中 `X` 是出问题的轮胎的编号；
- 如果需要检查所有轮胎，输出 `Warning: please check all the tires!`。

### 输入样例 1：

```in
242 251 231 248 230 20
```

### 输出样例 1：

```out
Normal
```

### 输入样例 2：

```in
242 251 232 248 230 10
```

### 输出样例 2：

```out
Warning: please check #3!
```

### 输入样例 3：

```in
240 251 232 248 240 10
```

### 输出样例 3：

```out
Warning: please check all the tires!
```

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int tirePressure[5] = {};
    bool ifAlert[5] = {};
    int minPressureAlert;
    int pressureDiffThreshold;
    cin >> tirePressure[1] >> tirePressure[2] >> tirePressure[3] >> tirePressure[4];
    cin >> minPressureAlert;
    cin >> pressureDiffThreshold;
    int maxTirePressure = max({tirePressure[1], tirePressure[2], tirePressure[3], tirePressure[4]});
    int badNum = 0;
    for (int i = 1; i <= 4; i++)
    {
        if (maxTirePressure - tirePressure[i] > pressureDiffThreshold || tirePressure[i] < minPressureAlert)
        {
            // cout << "Warning: please check #" << i << "!" << endl;
            ifAlert[i] = 1;
            badNum++;
        }
    }
    if (badNum >= 2)
        cout << "Warning: please check all the tires!" << endl;
    else if (badNum == 0)
        cout << "Normal";
    else
    {
        for (int i = 1; i <= 4; i++)
        {
            if (ifAlert[i] == 1)
                cout << "Warning: please check #" << i << "!" << endl;
        }
    }
    return 0;
}
```

## **7-19 大笨钟的心情**

分数 15

作者 陈越

单位 浙江大学

![心情.jpg](https://images.ptausercontent.com/8c3b8713-1703-4e56-addb-492f738c3a7c.jpg)

有网友问：未来还会有更多大笨钟题吗？笨钟回复说：看心情……

本题就请你替大笨钟写一个程序，根据心情自动输出回答。

### 输入格式：

输入在一行中给出 24 个 [0, 100] 区间内的整数，依次代表大笨钟在一天 24 小时中，每个小时的心情指数。

随后若干行，每行给出一个 [0, 23] 之间的整数，代表网友询问笨钟这个问题的时间点。当出现非法的时间点时，表示输入结束，这个非法输入不要处理。题目保证至少有 1 次询问。

### 输出格式：

对每一次提问，如果当时笨钟的心情指数大于 50，就在一行中输出 `心情指数 Yes`，否则输出 `心情指数 No`。

### 输入样例：

```in
80 75 60 50 20 20 20 20 55 62 66 51 42 33 47 58 67 52 41 20 35 49 50 63
17
7
3
15
-1
```

### 输出样例：

```out
52 Yes
20 No
50 No
58 Yes
```

代码长度限制

16 KB

Java (javac)

时间限制

600 ms

内存限制

64 MB

其他编译器

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int moodIndices[24];
    for (int i = 0; i < 24; i++)
    {
        cin >> moodIndices[i];
    }
    int queryTime;
    cin >> queryTime;
    while (1)
    {
        if (queryTime < 0 || queryTime > 23)
            break;
        if (moodIndices[queryTime] > 50)
            cout << moodIndices[queryTime] << " Yes" << endl;
        else
            cout << moodIndices[queryTime] << " No" << endl;
        cin >> queryTime;
    }
    return 0;
}
```

## **7-20 统计工龄**

分数 15

作者 陈越

单位 浙江大学

给定公司 *n* 名员工的工龄，要求按工龄增序输出每个工龄段有多少员工。

### 输入格式:

输入首先给出正整数 *n*（≤105），即员工总人数；随后给出 *n* 个整数，即每个员工的工龄，范围在 [0, 50]。

### 输出格式:

按工龄的递增顺序输出每个工龄的员工个数，格式为：“工龄:人数”。每项占一行。如果人数为 0 则不输出该项。

### 输入样例:

```in
8
10 2 0 5 7 2 5 2
```

### 输出样例:

```out
0:1
2:3
5:2
7:1
10:1
```

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n;
    cin >> n;
    vector<int> workAge;
    workAge.resize(51);
    while (n--)
    {
        int tempNum;
        cin >> tempNum;
        workAge[tempNum]++;
    }
    for (int i = 0; i < workAge.size(); i++)
    {
        if (workAge[i])
            cout << i << ":" << workAge[i] << endl;
    }
    return 0;
}
```

## **7-22 符号配对**

分数 15

作者 DS课程组

单位 浙江大学

请编写程序检查C语言源程序中下列符号是否配对：`/*`与`*/`、`(`与`)`、`[`与`]`、`{`与`}`。

### 输入格式:

输入为一个C语言源程序。当读到某一行中只有一个句点`.`和一个回车的时候，标志着输入结束。程序中需要检查配对的符号不超过100个。

### 输出格式:

首先，如果所有符号配对正确，则在第一行中输出`YES`，否则输出`NO`。然后在第二行中指出第一个不配对的符号：如果缺少左符号，则输出`?-右符号`；如果缺少右符号，则输出`左符号-?`。

### 输入样例1：

```in
void test()
{
    int i, A[10];
    for (i=0; i<10; i++) { /*/
        A[i] = i;
}
.
```

### 输出样例1：

```out
NO
/*-?
```

### 输入样例2：

```
void test()
{
    int i, A[10];
    for (i=0; i<10; i++) /**/
        A[i] = i;
}]
.
```

### 输出样例2：

```
NO
?-]
```

### 输入样例3：

```
void test()
{
    int i
    double A[10];
    for (i=0; i<10; i++) /**/
        A[i] = 0.1*i;
}
.
```

### 输出样例3：

```
YES
```

**鸣谢用户 王渊博 补充数据！**

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;
int main()
{
    string symbolRepository = "";
    while (true)
    {
        string tempStr;
        getline(cin, tempStr);
        if (tempStr == ".\0")
            break;
        for (int i = 0; i < tempStr.size(); i++)
        {
            if (tempStr[i] == '(' || tempStr[i] == '[' || tempStr[i] == '{' || tempStr[i] == ')' || tempStr[i] == ']' || tempStr[i] == '}')
                symbolRepository += tempStr[i];
            else if (tempStr[i] == '/' && tempStr[i + 1] == '*')
            {
                symbolRepository += '<';
                i++;
            }
            else if (tempStr[i] == '*' && tempStr[i + 1] == '/')
            {
                symbolRepository += '>';
                i++;
            }
        }
    }
    map<char, char> symbolPartner;
    symbolPartner['('] = ')';
    symbolPartner['['] = ']';
    symbolPartner['{'] = '}';
    symbolPartner['<'] = '>';
    stack<char> symbolBag;
    for (int i = 0; i < symbolRepository.size(); i++)
    {
        if (symbolRepository[i] == '(' || symbolRepository[i] == '[' || symbolRepository[i] == '{' || symbolRepository[i] == '<')
            symbolBag.push(symbolRepository[i]);
        else if (symbolRepository[i] == ')' || symbolRepository[i] == ']' || symbolRepository[i] == '}' || symbolRepository[i] == '>')
        {
            if (symbolBag.empty()) // 栈为空，说明缺少左符号
            {
                cout << "NO" << endl;
                if (symbolRepository[i] == '>')
                    cout << "?-*/";
                else
                    cout << "?-" << symbolRepository[i];
                return 0;
            }
            else if (symbolPartner[symbolBag.top()] == symbolRepository[i])
                symbolBag.pop();
            else if (symbolPartner[symbolBag.top()] != symbolRepository[i]) // top不匹配，说明匹配错误，并且缺少右符号
            {
                cout << "NO" << endl;
                if (symbolBag.top() == '<')
                    cout << "/*-?";
                else
                    cout << symbolBag.top() << "-?";
                return 0;
            }
        }
    }
    if (symbolBag.empty())
        cout << "YES";
    else
    {
        if (symbolBag.top() == '<')
            cout << "NO" << endl
                 << "/*-?";
        else
        {
            cout << "NO" << endl
                 << symbolBag.top() << "-?";
        }
    }
}
```

## **7-23 栈操作的合法性**

分数 15

作者 DS课程组

单位 浙江大学

假设以`S`和`X`分别表示入栈和出栈操作。如果根据一个仅由`S`和`X`构成的序列，对一个空堆栈进行操作，相应操作均可行（如没有出现删除时栈空）且最后状态也是栈空，则称该序列是合法的堆栈操作序列。请编写程序，输入`S`和`X`序列，判断该序列是否合法。

### 输入格式:

输入第一行给出两个正整数 *n* 和 *m*，其中 *n* 是待测序列的个数，*m*（≤50）是堆栈的最大容量。随后 *n* 行，每行中给出一个仅由`S`和`X`构成的序列。序列保证不为空，且长度不超过100。

### 输出格式:

对每个序列，在一行中输出`YES`如果该序列是合法的堆栈操作序列，或`NO`如果不是。

### 输入样例：

```in
4 10
SSSXXSXXSX
SSSXXSXXS
SSSSSSSSSSXSSXXXXXXXXXXX
SSSXXSXXX
```

### 输出样例：

```out
YES
NO
NO
NO
```

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n, m;
    cin >> n >> m;
    while (n--)
    {
        stack<char> charBag;
        string operationStr;
        cin >> operationStr;
        bool ifOut = 0;
        for (char opeChar : operationStr)
        {
            if (opeChar == 'S')
            {
                charBag.push(opeChar);
                if (charBag.size() > m)
                {
                    cout << "NO" << endl;
                    ifOut = 1;
                    break;
                }
            }
            else if (opeChar == 'X' && charBag.size() == 0)
            {
                cout << "NO" << endl;
                ifOut = 1;
                break;
            }
            else
                charBag.pop();
        }
        if (charBag.size() == 0 && ifOut == 0)
            cout << "YES" << endl;
        else if (charBag.size() != 0 && ifOut == 0)
            cout << "NO" << endl;
    }
    return 0;
}
```

## **7-24 链表去重**

分数 15

作者 陈越

单位 浙江大学

给定一个带整数键值的链表 L，你需要把其中绝对值重复的键值结点删掉。即对每个键值 K，只有第一个绝对值等于 K 的结点被保留。同时，所有被删除的结点须被保存在另一个链表上。例如给定 L 为 21→-15→-15→-7→15，你需要输出去重后的链表 21→-15→-7，还有被删除的链表 -15→15。

### 输入格式：

输入在第一行给出 L 的第一个结点的地址和一个正整数 N（≤105，为结点总数）。一个结点的地址是非负的 5 位整数，空地址 NULL 用 -1 来表示。

随后 N 行，每行按以下格式描述一个结点：

```
地址 键值 下一个结点
```

其中`地址`是该结点的地址，`键值`是绝对值不超过104的整数，`下一个结点`是下个结点的地址。

### 输出格式：

首先输出去重后的链表，然后输出被删除的链表。每个结点占一行，按输入的格式输出。

### 输入样例：

```in
00100 5
99999 -7 87654
23854 -15 00000
87654 15 -1
00000 -15 99999
00100 21 23854
```

### 输出样例：

```out
00100 21 23854
23854 -15 99999
99999 -7 -1
00000 -15 87654
87654 15 -1
```

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;

struct node
{
    string nodeAddress;
    int nodeValue;
    string nextAddress;
    node()
    {
    }
};

main()
{
    string addressFirst;
    int N;
    cin >> addressFirst >> N;
    vector<node> nodeList;
    unordered_map<string, node> addressNode;
    // 输入所有的节点
    for (int i = 0; i < N; i++)
    {
        node tempNode;
        cin >> tempNode.nodeAddress >> tempNode.nodeValue >> tempNode.nextAddress;
        addressNode.insert(make_pair(tempNode.nodeAddress, tempNode));
        nodeList.push_back(tempNode);
    }
    // 开始检查分类重复节点和非重复节点
    vector<node> repeatedNode;
    vector<node> noRepeatedNode;
    bool ifExist[10001] = {false};
    node tempNode = addressNode[addressFirst];
    while (true)
    {
        if (!ifExist[abs(tempNode.nodeValue)]) // 没有出现过
        {
            noRepeatedNode.push_back(tempNode);
            ifExist[abs(tempNode.nodeValue)] = true;
        }
        else
        {
            repeatedNode.push_back(tempNode);
        }
        if (tempNode.nextAddress == "-1")
            break;
        else
            tempNode = addressNode[tempNode.nextAddress];
    }
    // 输出节点
    // 非重复节点
    for (int i = 0; i < noRepeatedNode.size(); i++)
    {
        cout << noRepeatedNode[i].nodeAddress << " " << noRepeatedNode[i].nodeValue << " ";
        if (i != noRepeatedNode.size() - 1)
            cout << noRepeatedNode[i + 1].nodeAddress << endl;
        else
            cout << "-1" << endl;
    }
    // 重复节点
    for (int i = 0; i < repeatedNode.size(); i++)
    {
        cout << repeatedNode[i].nodeAddress << " " << repeatedNode[i].nodeValue << " ";
        if (i != repeatedNode.size() - 1)
            cout << repeatedNode[i + 1].nodeAddress << endl;
        else
            cout << "-1" << endl;
    }
}
```

## **7-21 装箱问题**

分数 15

作者 DS课程组

单位 浙江大学

假设有*N*项物品，大小分别为*s*1、*s*2、…、*s**i*、…、*s**N*，其中*s**i*为满足1≤*s**i*≤100的整数。要把这些物品装入到容量为100的一批箱子（序号1-*N*）中。装箱方法是：对每项物品, 顺序扫描箱子，把该物品放入足以能够容下它的第一个箱子中。请写一个程序模拟这种装箱过程，并输出每个物品所在的箱子序号，以及放置全部物品所需的箱子数目。

### 输入格式：

输入第一行给出物品个数*N*（≤1000）；第二行给出*N*个正整数*s**i*（1≤*s**i*≤100，表示第*i*项物品的大小）。

### 输出格式：

按照输入顺序输出每个物品的大小及其所在的箱子序号，每个物品占1行，最后一行输出所需的箱子数目。

### 输入样例：

```in
8
60 70 80 90 30 40 10 20
```

### 输出样例：

```out
60 1
70 2
80 3
90 4
30 1
40 5
10 1
20 2
5
```

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int N;
    cin >> N;
    vector<int> s;
    s.push_back(100);
    for (int i = 1; i <= N; i++)
    {
        int tempS;
        cin >> tempS;
        s.push_back(tempS);
    }
    vector<int> sBag;
    sBag.push_back(100);
    sBag.push_back(0);
    for (int i = 1; i <= N; i++)
    {
        for (int j = 1; j <= sBag.size() - 1; j++)
        {
            if (s[i] + sBag[j] <= 100)
            {
                sBag[j] += s[i];
                cout << s[i] << " " << j << endl;
                s[i] = -1;
                break;
            }
        }
        if (s[i] != -1)
        {
            sBag.push_back(s[i]);
            cout << s[i] << " " << sBag.size() - 1 << endl;
            s[i] = -1;
        }
    }
    cout << sBag.size() - 1;
    return 0;
}
```

## **7-25 愿天下有情人都是失散多年的兄妹**（）

分数 15

作者 陈越

单位 浙江大学

呵呵。大家都知道五服以内不得通婚，即两个人最近的共同祖先如果在五代以内（即本人、父母、祖父母、曾祖父母、高祖父母）则不可通婚。本题就请你帮助一对有情人判断一下，他们究竟是否可以成婚？

### 输入格式：

输入第一行给出一个正整数`N`（2 ≤ `N` ≤104），随后`N`行，每行按以下格式给出一个人的信息：

```
本人ID 性别 父亲ID 母亲ID
```

其中`ID`是5位数字，每人不同；性别`M`代表男性、`F`代表女性。如果某人的父亲或母亲已经不可考，则相应的`ID`位置上标记为`-1`。

接下来给出一个正整数`K`，随后`K`行，每行给出一对有情人的`ID`，其间以空格分隔。

注意：题目保证两个人是同辈，每人只有一个性别，并且血缘关系网中没有乱伦或隔辈成婚的情况。

### 输出格式：

对每一对有情人，判断他们的关系是否可以通婚：如果两人是同性，输出`Never Mind`；如果是异性并且关系出了五服，输出`Yes`；如果异性关系未出五服，输出`No`。

### 输入样例：

```in
24
00001 M 01111 -1
00002 F 02222 03333
00003 M 02222 03333
00004 F 04444 03333
00005 M 04444 05555
00006 F 04444 05555
00007 F 06666 07777
00008 M 06666 07777
00009 M 00001 00002
00010 M 00003 00006
00011 F 00005 00007
00012 F 00008 08888
00013 F 00009 00011
00014 M 00010 09999
00015 M 00010 09999
00016 M 10000 00012
00017 F -1 00012
00018 F 11000 00013
00019 F 11100 00018
00020 F 00015 11110
00021 M 11100 00020
00022 M 00016 -1
00023 M 10012 00017
00024 M 00022 10013
9
00021 00024
00019 00024
00011 00012
00022 00018
00001 00004
00013 00016
00017 00015
00019 00021
00010 00011
```

### 输出样例：

```out
Never Mind
Yes
Never Mind
No
Yes
No
Yes
No
No
```

**鸣谢用户 徐校波 修正数据！**

代码长度限制

16 KB

时间限制

200 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;

bool al[100001] = { 0 };
bool flag = 0;
//int depth = 1;

typedef struct relation {
    int me;
    char gender;
    int father;
    int mother;
    relation(int _me = -1, int _father = -1, int _mother = -1, char _gender = 'M') :me(_me), father(_father), mother(_mother), gender(_gender) {}
}node;

node rela[100001];

void preorder(int id,int depth) {
    if (id == -1 || depth > 5) {
        return;
    }
    if (al[id]) {
        flag = 1;
    }
    else {
        al[id] = 1;
    }
    preorder(rela[id].father,depth+1);
    preorder(rela[id].mother,depth+1);
}

int main() {
    int n;
    cin >> n;
    int num;
    for (int i = 0; i < n; i++) {
        cin >> num;
        rela[num].me = num;
        cin >> rela[num].gender >> \
            rela[num].father >> rela[num].mother;
        //注意这里是个易错点，题目给出了父母的ID其实就已经隐式地表达了该ID的性别了。（在这里卡了不少时间）
        if (rela[num].father != -1)
            rela[rela[num].father].gender = 'M';
        if (rela[num].mother != -1)
            rela[rela[num].mother].gender = 'F';
    }
    int k;
    cin >> k;
    for (int i = 0; i < k; i++) {
        int p1, p2;
        cin >> p1 >> p2;
        if (rela[p1].gender == rela[p2].gender) {
            cout << "Never Mind" << endl;
            continue;
        }
        memset(al, 0, sizeof(al));
        flag = 0;
        preorder(p1,1);
        preorder(p2,1);
        if (flag)
            cout << "No" << endl;
        else
            cout << "Yes" << endl;
    }
    return 0;
}

```

## **7-26 深入虎穴**

分数 15

作者 陈越

单位 浙江大学

著名的王牌间谍 007 需要执行一次任务，获取敌方的机密情报。已知情报藏在一个地下迷宫里，迷宫只有一个入口，里面有很多条通路，每条路通向一扇门。每一扇门背后或者是一个房间，或者又有很多条路，同样是每条路通向一扇门…… 他的手里有一张表格，是其他间谍帮他收集到的情报，他们记下了每扇门的编号，以及这扇门背后的每一条通路所到达的门的编号。007 发现不存在两条路通向同一扇门。

内线告诉他，情报就藏在迷宫的最深处。但是这个迷宫太大了，他需要你的帮助 —— 请编程帮他找出距离入口最远的那扇门。

### 输入格式：

输入首先在一行中给出正整数 *N*（<105），是门的数量。最后 *N* 行，第 *i* 行（1≤*i*≤*N*）按以下格式描述编号为 *i* 的那扇门背后能通向的门：

```
K D[1] D[2] ... D[K]
```

其中 `K` 是通道的数量，其后是每扇门的编号。

### 输出格式：

在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。

### 输入样例：

```in
13
3 2 3 4
2 5 6
1 7
1 8
1 9
0
2 11 10
1 13
0
0
1 12
0
0
```

### 输出样例：

```out
12
```

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;

queue<int> q;
int in[100003] = { 0 };
vector<int> out[100003];

int bfs(int s) {
    q.push(s);
    int ans = s;//这里是易错点，第二个点一直过不去就是没考虑到没有路的情况
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int i = 0; i < out[u].size(); i++) {
            q.push(out[u][i]);
            ans = out[u][i];
        }
    }
    return ans;
}

int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int k;
        cin >> k;
        while (k--) {
            int d;
            cin >> d;
            out[i].push_back(d);
            in[d]++;
        }
    }
    int s = 0;
    //隐藏信息：只有一个入口，即只有一个点的入度为零；
    while (n) {
        if (!in[n]) {
            s = n;
            //break;
        }
        n--;
    }
    
    cout << bfs(s);
    return 0;
}

```

## **7-27 样本方差**

分数 15

作者 ldm

单位 成都信息工程大学

![u=3226723262,278720713&fm=15&gp=0.jpg](https://images.ptausercontent.com/f9228bf8-d573-4621-a2f9-b2c8c9d480a4.jpg)

作为概率论随便考100分的你，口算出给定样本的方差自然也不在话下，不过今天需要你编程实现这样的程序。

样本方差：*S*2=*n*−11∑*i*=1*n*(*X**i*−*X*ˉ)2

样本均值：*X*ˉ=*n*1∑*i*=1*n**X**i*

### 输入格式:

输入共两行。

第一行为一个正整数*n*,(2≤*n*≤10000)，即给定样本的数量。

第二行为*n*个整数，为每个样本的值。

### 输出格式:

输出仅 1 行，为计算出来的样本方差（保留 2 位小数，不足用 0 补齐）。

### 输入样例:

```in
4
974 559 974 233
```

### 输出样例:

```out
129074.00
```

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;

// 计算均值
double averageNum(vector<int> numBag)
{
    int sumNum = 0;
    for (int num : numBag)
    {
        sumNum += num;
    }
    double avgNum = sumNum * 1.0 / numBag.size();
    return avgNum;
}

// 计算方差
double sampleVariance(vector<int> numBag, double avgNum)
{
    double tempSum = 0.0;
    for (int tempNum : numBag)
    {
        // 计算平方的和
        tempSum += pow(tempNum - avgNum, 2);
    }
    double sampVari = tempSum / (numBag.size() - 1);
    return sampVari;
}

int main()
{
    int n;
    cin >> n;
    vector<int> numBag;
    // 输入数字
    for (int i = 0; i < n; i++)
    {
        int tempNum;
        cin >> tempNum;
        numBag.push_back(tempNum);
    }
    // 计算样本均值
    double avgNum = averageNum(numBag);
    // 计算样本方差
    double sampVari = sampleVariance(numBag, avgNum);
    cout << fixed << setprecision(2) << sampVari << endl;
    return 0;
}

```

