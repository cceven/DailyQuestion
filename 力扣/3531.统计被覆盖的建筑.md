[3531](https://leetcode.cn/problems/count-covered-buildings/description/?envType=daily-question&envId=2025-12-11)
我们需要寻找被包围起来的建筑，但是题目没有严格要求被包围的建筑是四个方向紧挨着一个建筑，而是只要四个方向都有建筑就算包围，不要求距离。于是我们可以遍历建筑，更新每一行最小/最大的列号，更新每一列最小/最大的行号。最后再遍历一次建筑物，如果这个建筑物的行号不是当前列最小/最大的，并且列号不是当前行最小/最大的，那么就符合条件，加1。
```cpp
class Solution {
public:
    int countCoveredBuildings(int n, vector<vector<int>>& buildings) {
        unordered_map<int, int> row_min_c, row_max_c, col_min_r, col_max_r;
        // 更新每行每列的最大列/行号
        for (auto& b : buildings) {
            int x = b[0], y = b[1];
            if (!row_min_c.count(x))
                row_min_c[x] = y;
            else
                row_min_c[x] = min(y, row_min_c[x]);

            if (!row_max_c.count(x))
                row_max_c[x] = y;
            else
                row_max_c[x] = max(y, row_max_c[x]);

            if (!col_min_r.count(y))
                col_min_r[y] = x;
            else
                col_min_r[y] = min(x, col_min_r[y]);

            if (!col_max_r.count(y))
                col_max_r[y] = x;
            else
                col_max_r[y] = max(x, col_max_r[y]);
        }
        // 只要满足行号不是当前列最小/最大的+列号不是当前行最小/最大的就符合条件
        int ans = 0;
        for (auto& b : buildings) {
            int x = b[0], y = b[1];
            if (x > col_min_r[y] && x < col_max_r[y] && y > row_min_c[x] &&
                y < row_max_c[x])
                ans++;
        }
        return ans;
    }
};
```