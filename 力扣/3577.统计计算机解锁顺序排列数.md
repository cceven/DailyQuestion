[3577](https://leetcode.cn/problems/count-the-number-of-computer-unlocking-permutations/solutions/3848629/tong-ji-ji-suan-ji-jie-suo-shun-xu-pai-l-tx3r/?envType=daily-question&envId=2025-12-10)
当有一个i<j，并且complexity\[i\]<complexity\[j\]就能够解锁j号，并且也必须有这样的一个i才能解锁j。如果j能够被一个不是0的i解锁，那么这个i继续往前追溯肯定也都是被0号解锁的，所以可以直接看0号能否解锁所有的计算机，也就是0号的complexity是数组中最小的。如果不是最小的，那么不可能解锁所有的计算机，否则结果就是除了0号计算机的随机排列组合。
```cpp
class Solution {
public:
    int countPermutations(vector<int>& complexity) {
        const int MOD = 1e9 + 7;
        long long root_val = complexity[0];
        int n = complexity.size();
        // 判断是否能够解锁，即后面的复杂性都小于0号
        for (int i = 1; i < n; ++i) {
            if (complexity[i] <= root_val)
                return 0;
        }

        long long ans = 1;
        // 除了0号，其他的随机排列组合
        for (int i = 1; i < n; ++i) {
            ans = (ans * i) % MOD;
        }
        return ans;
    }
};
```