[3578](https://leetcode.cn/problems/count-partitions-with-max-min-difference-at-most-k/solutions/3843928/tong-ji-ji-chai-zui-da-wei-k-de-fen-ge-f-spi4/?envType=daily-question&envId=2025-12-06)
### 1. 核心思维：从暴力到优化的演变
#### 第一步：定义状态 (DP Modeling)
看到“将数组分割成若干段”、“求方案数”，首先想到的就是**动态规划**。
定义 $dp[i]$ 为：**将数组的前 $i$ 个元素 `nums[0...i-1]` 合法分割的方案总数**。
- **目标**：求 $dp[n]$。
- **基准**：$dp[0] = 1$（空数组视为一种切分方案）。
#### 第二步：状态转移方程
对于当前位置 $i$（也就是考虑子数组 nums[0...i-1]），这最后一段可以是 nums[j...i-1]。
只要这一段满足条件（最大值 - 最小值 $\le k$），那么前面的 nums[0...j-1] 的所有切分方案都可以接上这一段。
$$dp[i] = \sum_{j < i, \text{ valid segment}} dp[j]$$
其中“valid segment”指的是 `nums[j...i-1]` 的极差 $\le k$。
#### 第三步：瓶颈分析
如果用暴力法：
1. 遍历 $i$ 从 1 到 $n$。
2. 遍历 $j$ 从 $0$ 到 $i-1$。
3. 检查 nums[j...i-1] 的最大最小值。
    时间复杂度会达到 $O(N^2)$ 甚至 $O(N^3)$。题目中 $N=50,000$，这绝对会超时。
我们需要将复杂度降到 $O(N)$。
---
### 2. 关键优化：滑动窗口与单调性
这里有两个优化点，是解决高阶DP问题的通用手段：
#### 优化点 A：寻找合法的 $j$ 的范围 (Monotonicity)
对于固定的右端点 $i$，随着左端点 $j$ 向左移动（$j$ 变小），区间 nums\[j...i-1\] 变长，其最大值可能变大，最小值可能变小。
这意味着：极差（Max - Min）随着区间变长是单调非递减的。
因此，对于每个 $i$，一定存在一个**最左边界** $L_i$。
- 当 $j \ge L_i$ 时，区间合法。
- 当 $j < L_i$ 时，区间非法（极差 $> k$）。
所以转移方程变成了区间求和：
$$dp[i] = \sum_{j=L_i}^{i-1} dp[j]$$
为了快速计算这个和，我们可以维护一个 dp 数组的前缀和 presum。
则 $dp[i] = (presum[i] - presum[L_i]) \pmod M$。
#### 优化点 B：如何快速维护 $L_i$ (Sliding Window Min/Max)
当 $i$ 增加时（窗口右移），$L_i$ 只会向右移动或保持不变（不可能向左，因为加了新元素极差只会更大）。
这是一个经典的滑动窗口最值问题。，我们需要**单调队列 (Monotonic Queue)**。
- **最大值单调队列 (`max_dq`)**：维护窗口内的递减序列，队头是当前窗口最大值的下标。
- **最小值单调队列 (`min_dq`)**：维护窗口内的递增序列，队头是当前窗口最小值的下标。
**算法流程：**
1. **入队**：处理 `nums[i]`，更新两个单调队列。
2. **收缩**：如果 `nums[max_dq.front()] - nums[min_dq.front()] > k`，说明当前窗口 `[L...i]` 不合法，需要让 $L$ 右移，直到合法为止。同时把下标小于新 $L$ 的元素从队头踢出。
3. **计算**：此时 $L$ 就是最左合法边界，利用前缀和计算 $dp[i+1]$。
```cpp
class Solution {
public:
    int countPartitions(vector<int>& nums, int k) {
        const int MOD = 1e9 + 7;
        int n = nums.size();
        vector<int> dp(n + 1);        // dp[i]表示前i个元素可以有的分法
        vector<int> prefix_dp(n + 2); // dp的前缀和
        dp[0] = 1;
        prefix_dp[1] = 1;

        int left = 0;              // 当前滑动窗口的左边界
        deque<int> max_dq, min_dq; // 分别存储当前窗口的最大值和最小值
        for (int i = 0; i < n; i++) {
            // 更新最大值和最小值元素列表
            while (!max_dq.empty() && (nums[max_dq.back()] <= nums[i])) {
                max_dq.pop_back();
            }
            max_dq.push_back(i);
            while (!min_dq.empty() && (nums[min_dq.back()] >= nums[i])) {
                min_dq.pop_back();
            }
            min_dq.push_back(i);
            // 如果破坏了题目条件，缩小窗口
            while (nums[max_dq.front()] - nums[min_dq.front()] > k) {
                left++;
                // 去除掉窗口外的元素
                if (max_dq.front() < left)
                    max_dq.pop_front();
                if (min_dq.front() < left)
                    min_dq.pop_front();
            }

            // 计算出当前的dp值
            dp[i + 1] = (prefix_dp[i + 1] - prefix_dp[left] + MOD) % MOD;

            // 计算出下一轮的prefix_dp值(prefix_dp不包含当前轮的dp)
            prefix_dp[i + 2] = (prefix_dp[i + 1] + dp[i + 1]) % MOD;
        }
        return dp[n];
    }
};
```