[3583](https://leetcode.cn/problems/count-special-triplets/?envType=daily-question&envId=2025-12-09)
使用两个`map`，一个维护前面的数字个数，一个维护后面的数字个数。
```cpp
class Solution {
public:
    int specialTriplets(vector<int>& nums) {
        unordered_map<int, int> leftMap, rightMap;
        int ans = 0;
        const int MOD = 1e9 + 7;
        for (auto& x : nums)
            rightMap[x]++;

        for (int i = 0; i < nums.size() - 1; i++) {
            rightMap[nums[i]]--;
            long long tar_num = (long long)nums[i] * 2;
            if (leftMap.count(tar_num) && rightMap.count(tar_num)) {
                int count =
                    ((long long)leftMap[tar_num] * rightMap[tar_num]) % MOD;
                ans = (ans + count) % MOD;
            }
            leftMap[nums[i]]++;
        }
        return ans;
    }
};
```