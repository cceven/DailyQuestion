[3625](https://leetcode.cn/problems/count-number-of-trapezoids-ii/submissions/682762788/?envType=daily-question&envId=2025-12-03)：统计给出点所能形成的不同的梯形的数目（至少有一对线段平行），所以我们的目标就变成了找平行的线段。判断线段是否平行我们可以使用**斜率**，判断线段是否共线我们可以使用**截距**(我们使用叉积原理计算)。我们就用一个`slopeMap`存储斜率和它对应的截距有哪些。最后我们遍历同一个斜率拥有的不同截距的线段数量即可得到可以形成的梯形数量。
存在的问题是，可能形成两对边都互相平行的情况，即平行四边形。这时平行四边形会被重复计算，我们的结果就是：非平行四边形梯形+2\*平行四边形。所以我们需要计算平行四边形的数量。使用一个`midMap`存储中点(防止出现分数，直接使用$x_1+x_2$和$y_1+y_2$作为中点坐标)和它对应的斜率有哪些。最后我们把上面计算的结果减去这里算出来的平行四边形数量就可以了。
```cpp
typedef long long ll;
class Solution {
public:
    int countTrapezoids(vector<vector<int>>& points) {
        int n = points.size();
        // 少于四个点，无法形成梯形
        if (n < 4)
            return 0;
        int ans = 0;
        map<pair<int, int>, vector<ll>>
            slopeMap; // 斜率：截距。存储每个斜率对应多少条不同的直线
        map<pair<int, int>, vector<pair<int, int>>>
            midMap; // 中点*2：对应的点。存储每个中点对应的斜率，如果大于1就说明有平行四边形
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                // 求斜率
                int dx = points[i][0] - points[j][0];
                int dy = points[i][1] - points[j][1];

                // 归一化
                int g = gcd(abs(dx), abs(dy));
                dx /= g, dy /= g;

                // 统一向量方向，保证向量只在第一象限+第四象限+y轴正向
                if (dx < 0 || (dx == 0 && dy < 0)) {
                    dx = -dx, dy = -dy;
                }

                // 当前的斜率
                pair<int, int> slope = {dx, dy};

                // 当前的截距(叉积原理)，区分不同的线段
                ll intercept = (ll)dx * points[i][1] - (ll)dy * points[i][0];
                // 使用中点的值的二倍，防止分数出现
                pair<int, int> mid2 = {points[i][0] + points[j][0],
                                       points[i][1] + points[j][1]};

                slopeMap[slope].push_back({intercept});
                midMap[mid2].push_back(slope);
            }
        }

        // 先把所有的梯形算出来
        for (auto& [slope, intercepts] : slopeMap) {
            if (intercepts.size() < 2)
                continue;

            // 每条截距对应的线段数量
            map<ll, int> lines;
            for (auto& c : intercepts) {
                lines[c]++;
            }
            // 只有一条直线，跳过
            if (lines.size() < 2)
                continue;

            int pre_num = 0;
            for (auto& l : lines) {
                ans += (ll)pre_num * l.second;
                pre_num += l.second;
            }
        }

        // 找到平行四边形并减去
        for (auto& [mid, slopes] : midMap) {
            if (slopes.size() < 2)
                continue;
            // 每个斜率对应的线段数量
            map<pair<int, int>, int> slopeCounts;
            for (auto& s : slopes) {
                slopeCounts[s]++;
            }
            if (slopeCounts.size() < 2)
                continue;

            int pre_num = 0;
            for (auto& s : slopeCounts) {
                ans -= (ll)pre_num * s.second;
                pre_num += s.second;
            }
        }
        return ans;
    }
};
```