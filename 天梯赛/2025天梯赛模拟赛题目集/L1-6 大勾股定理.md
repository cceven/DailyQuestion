# **L1-6 大勾股定理**

分数 15

作者 陈越

单位 浙江大学

**大勾股定理**是勾股定理的推广：对任何正整数 *n* 存在 2*n*+1 个连续正整数，满足前 *n*+1 个数的平方和等于后 *n* 个数的平方和。例如对于 *n*=1 有 32+42=52；*n*=2 有 102+112+122=132+142 等。给定 *n*，本题就请你找出对应的解。

## 输入格式：

输入在一行中给出正整数 *n*（≤104）。

## 输出格式：

分两行输出满足大勾股定理的解，格式如下：

```
a[0]^2 + a[1]^2 + ... + a[n]^2 =
a[n+1]^2 + ... + a[2n]^2
```

其中解的数列 `a[0] ... a[2n]` 按递增序输出。注意行首尾不得有多余空格。

## 输入样例：

```in
3
```

## 输出样例：

```out
21^2 + 22^2 + 23^2 + 24^2 =
25^2 + 26^2 + 27^2
```

代码长度限制

16 KB

时间限制

250 ms

内存限制

64 MB

栈限制

8192 KB

## 代码

暴力做法超时，打表得出规律

```cpp
#include <bits/stdc++.h>
#define endl "\n"
using namespace std;
using ll = long long;
#define int ll

void solve() {
  int n;
  cin >> n;

  // 打表得出来的结论
  int start_pos = n * (2 * n + 1);

  int pre_sum = 0;     // 前半部分的和
  queue<int> pre_num;  // 前半部分的数字
  for (int i = start_pos; i <= start_pos + n; i++) {
    pre_sum += i * i;
    pre_num.push(i);
  }

  int cur_sum = 0;     // 后半部分的和
  queue<int> cur_num;  // 后半部分的数字
  for (int i = start_pos + n + 1; i <= start_pos + 2 * n; i++) {
    cur_sum += i * i;
    cur_num.push(i);
  }

  // int o = 1, p = n + 2, q = 2 * n + 2;
  // while (pre_sum != cur_sum) {
  //   pre_sum -= o * o;
  //   pre_num.pop();
  //   o++;

  // pre_sum += p * p;
  // cur_sum -= p * p;
  // pre_num.push(p);
  // cur_num.pop();
  // p++;

  // cur_sum += q * q;
  // cur_num.push(q);
  // q++;
  // }

  // 输出答案
  bool is_first = true;
  while (!pre_num.empty()) {
    if (is_first)
      is_first = false;
    else
      cout << " + ";
    cout << pre_num.front() << "^2";
    pre_num.pop();
  }
  cout << " =" << endl;

  is_first = true;
  while (!cur_num.empty()) {
    if (is_first)
      is_first = false;
    else
      cout << " + ";
    cout << cur_num.front() << "^2";
    cur_num.pop();
  }
}

signed main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int t = 1;
  // cin >> t;
  while (t--) {
    solve();
  }
  return 0;
}
```

