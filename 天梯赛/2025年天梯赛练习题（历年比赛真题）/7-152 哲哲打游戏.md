# **7-152 哲哲打游戏**

分数 25

作者 DAI, Longao

单位 杭州百腾教育科技有限公司

哲哲是一位硬核游戏玩家。最近一款名叫《达诺达诺》的新游戏刚刚上市，哲哲自然要快速攻略游戏，守护硬核游戏玩家的一切！

为简化模型，我们不妨假设游戏有 *N* 个剧情点，通过游戏里不同的操作或选择可以从某个剧情点去往另外一个剧情点。此外，游戏还设置了一些**存档**，在某个剧情点可以将玩家的游戏进度保存在一个档位上，读取存档后可以回到剧情点，重新进行操作或者选择，到达不同的剧情点。

为了追踪硬核游戏玩家哲哲的攻略进度，你打算写一个程序来完成这个工作。假设你已经知道了游戏的全部剧情点和流程，以及哲哲的游戏操作，请你输出哲哲的游戏进度。

## 输入格式：

输入第一行是两个正整数 *N* 和 *M* (1≤*N*,*M*≤105)，表示总共有 *N* 个剧情点，哲哲有 *M* 个游戏操作。

接下来的 *N* 行，每行对应一个剧情点的发展设定。第 *i* 行的第一个数字是 *K**i*，表示剧情点 *i* 通过一些操作或选择能去往下面 *K**i* 个剧情点；接下来有 *K**i* 个数字，第 *k* 个数字表示做第 *k* 个操作或选择可以去往的剧情点编号。

最后有 *M* 行，每行第一个数字是 0、1 或 2，分别表示：

- 0 表示哲哲做出了某个操作或选择，后面紧接着一个数字 *j*，表示哲哲在当前剧情点做出了第 *j* 个选择。我们保证哲哲的选择永远是合法的。
- 1 表示哲哲进行了一次存档，后面紧接着是一个数字 *j*，表示存档放在了第 *j* 个档位上。
- 2 表示哲哲进行了一次读取存档的操作，后面紧接着是一个数字 *j*，表示读取了放在第 *j* 个位置的存档。

约定：所有操作或选择以及剧情点编号都从 1 号开始。存档的档位不超过 100 个，编号也从 1 开始。游戏默认从 1 号剧情点开始。总的选项数（即 ∑*K**i*）不超过 106。

## 输出格式：

对于每个 1（即存档）操作，在一行中输出存档的剧情点编号。

最后一行输出哲哲最后到达的剧情点编号。

## 输入样例：

```in
10 11
3 2 3 4
1 6
3 4 7 5
1 3
1 9
2 3 5
3 1 8 5
1 9
2 8 10
0
1 1
0 3
0 1
1 2
0 2
0 2
2 2
0 3
0 1
1 1
0 2
```

## 输出样例：

```out
1
3
9
10
```

## 样例解释：

简单给出样例中经过的剧情点顺序：

1 -> 4 -> 3 -> 7 -> 8 -> 3 -> 5 -> 9 -> 10。

档位 1 开始存的是 1 号剧情点；档位 2 存的是 3 号剧情点；档位 1 后来又存了 9 号剧情点。

代码长度限制

16 KB

Java (javac)

时间限制

800 ms

内存限制

64 MB

Python (python3)

时间限制

1000 ms

内存限制

64 MB

其他编译器

时间限制

400 ms

内存限制

64 MB

栈限制

8192 KB

## 代码

```cpp
#include <bits/stdc++.h>
#define endl "\n"
using namespace std;
typedef long long ll;

void solve() {
  int N, M;
  cin >> N >> M;

  vector<vector<int>> game_pos(N + 1);
  for (int i = 1; i <= N; i++) {
    int K;  // 表示有K个通向
    cin >> K;
    game_pos[i].resize(K + 1);
    for (int j = 1; j <= K; j++) {
      cin >> game_pos[i][j];
    }
  }

  // 现在开始进行游戏操作
  int curr_pos = 1;
  vector<int> archives(101);
  for (int turn = 1; turn <= M; turn++) {
    int ope, j;
    cin >> ope >> j;

    if (ope == 0) {  // 如果选择0,那么更换当前位置
      curr_pos = game_pos[curr_pos][j];
    } else if (ope == 1) {  // 如果选择1,那么更新存档
      archives[j] = curr_pos;
      cout << curr_pos << endl;
    } else if (ope == 2) {  // 如果选择2,那么读取存档
      curr_pos = archives[j];
    }
  }
  cout << curr_pos;
}

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  solve();
  return 0;
}
```

