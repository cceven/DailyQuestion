# **7-155 龙龙送外卖**

分数 25

作者 DAI, Longao

单位 杭州百腾教育科技有限公司

龙龙是“饱了呀”外卖软件的注册骑手，负责送帕特小区的外卖。帕特小区的构造非常特别，都是双向道路且没有构成环 —— 你可以简单地认为小区的路构成了一棵树，根结点是外卖站，树上的结点就是要送餐的地址。

每到中午 12 点，帕特小区就进入了点餐高峰。一开始，只有一两个地方点外卖，龙龙简单就送好了；但随着大数据的分析，龙龙被派了更多的单子，也就送得越来越累……

看着一大堆订单，龙龙想知道，从外卖站出发，访问所有点了外卖的地方至少一次（这样才能把外卖送到）所需的最短路程的距离到底是多少？每次新增一个点外卖的地址，他就想估算一遍整体工作量，这样他就可以搞明白新增一个地址给他带来了多少负担。

## 输入格式:

输入第一行是两个数 *N* 和 *M* (2≤*N*≤105, 1≤*M*≤105)，分别对应树上节点的个数（包括外卖站），以及新增的送餐地址的个数。

接下来首先是一行 *N* 个数，第 *i* 个数表示第 *i* 个点的双亲节点的编号。节点编号从 1 到 *N*，外卖站的双亲编号定义为 −1。

接下来有 *M* 行，每行给出一个新增的送餐地点的编号 *X**i*。保证送餐地点中不会有外卖站，但地点有可能会重复。

为了方便计算，我们可以假设龙龙一开始一个地址的外卖都不用送，两个相邻的地点之间的路径长度统一设为 1，且从外卖站出发可以访问到所有地点。

注意：所有送餐地址可以按任意顺序访问，***且完成送餐后无需返回外卖站***。

## 输出格式:

对于每个新增的地点，在一行内输出题目需要求的最短路程的距离。

## 输入样例:

```in
7 4
-1 1 1 1 2 2 3
5
6
2
4
```

## 输出样例:

```out
2
4
4
6
```

代码长度限制

16 KB

Java (javac)

时间限制

1400 ms

内存限制

256 MB

Python (python3)

时间限制

600 ms

内存限制

64 MB

其他编译器

时间限制

400 ms

内存限制

64 MB

栈限制

131072 KB

## 代码

```cpp
#include <bits/stdc++.h>
#define endl "\n"
using namespace std;
typedef long long ll;

vector<int> par;
int max_depth = 0;  // 最长单程路径
vector<int> dist;   // 每个节点到根节点的距离

int dfs(int node, int depth) {
  max_depth = max(max_depth, depth + dist[node]);  // 首先更新最长路径
  // 如果到达了根节点，或者到达了已经访问过的节点，那么就可以直接返回需要增加的往返距离
  if (par[node] == -1 || dist[node] != 0) return 2 * depth;
  // 否则继续往根的方向遍历
  int sum = dfs(par[node], depth + 1);
  // 更新当前节点到根节点的距离
  dist[node] = dist[par[node]] + 1;
  return sum;
}

void solve() {
  int N, M;
  cin >> N >> M;
  dist.resize(N + 1, 0);

  // 输入每个节点的父节点
  par.resize(N + 1);
  for (int i = 1; i <= N; i++) {
    cin >> par[i];
  }

  // 开始寻找最短路程
  int sum = 0;
  for (int i = 1; i <= M; i++) {
    int node;
    cin >> node;
    sum += dfs(node, 0);
    // 我们默认每个节点都是需要往返，但是最长的那条路只需要走一遍，所以需要减一个最长单程路径
    cout << sum - max_depth << endl;
  }
}

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  solve();
  return 0;
}
```

