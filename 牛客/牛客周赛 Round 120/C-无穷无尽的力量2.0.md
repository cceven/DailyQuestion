[无穷无尽的力量2.0](https://ac.nowcoder.com/acm/contest/123788/C)
连通性原理：只要棋盘大小允许马进行“局部腾挪”（也就是凑出从(x, y)到邻居(x+1,y)的路径），马就能遍历全图）。
马走的规则就是$(\pm 1, \pm 2)$或者$(\pm 2, \pm 1)$。如果一个(1, 1)的点想要走到(1, 2)。那么可以的走法是：(1, 1) -> (2, 3) -> (3, 1) -> (1, 2)，需要的最大的活动范围也就是$3\times3$，所以理论上只要棋盘的大小大于等于这个值，就能遍历整个棋盘。
但是需要注意的是，如果棋盘的大小刚好是$3\times3$，那么棋盘的中心点和周围的点是分隔开的，中心点无法到达任何一个点但是周围的点互相联通，所以$3\times3$要特殊判断一下。现在看棋盘小于$3 \times 3$的情况。
假定棋盘大小为$n \times m$，且$n<m$（如果n更大，换一下n和m就可以了）。
- n=1时，无论m为多少都无法移动。
- n=2时，马只能从棋盘的一端线性到达另一端。
综上，代码如下：
```cpp
#include <bits/stdc++.h>
#define endl "\n"
using namespace std;
using ll = long long;
#define int ll

void solve() {
  int n, m;
  cin >> n >> m;
  if (n > m) swap(n, m);
  int ans = 0;
  if (n == 1)
    ans = 1;
  else if (n == 2)
    ans = (m + 1) / 2;
  else if (n == 3 && m == 3)
    ans = 8;
  else
    ans = n * m;
  cout << ans << endl;
}

signed main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  int t = 1;
  // cin >> t;
  while (t--) solve();
  return 0;
}
```